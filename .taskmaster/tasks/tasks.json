{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Git Repository and Basic Structure",
        "description": "Set up the basic Git repository structure for the numis library.",
        "details": "Initialize a git repository. Create basic project directories (e.g., `src`, `test`). Add a `.gitignore` file.",
        "testStrategy": "Verify repository is initialized and basic structure is present.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure TypeScript Compiler (tsconfig.json)",
        "description": "Configure the TypeScript compiler for the project, targeting Node >= 18 and modern browsers, and enabling dual ESM/CJS output.",
        "details": "Install TypeScript. Create and configure `tsconfig.json` for dual ESM/CJS builds (e.g., using `moduleResolution`, `module`, `outDir`). Ensure compatibility with Node >= 18 and modern browsers.",
        "testStrategy": "Compile a simple test file to verify ESM and CJS output directories and file types are generated correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Configure ESLint with Airbnb-base Rules",
        "description": "Set up ESLint with the Airbnb-base configuration and integrate it into the project.",
        "details": "Install ESLint and `eslint-config-airbnb-base`. Configure ESLint via `.eslintrc.js` or similar, extending the Airbnb-base config. Add lint scripts to `package.json`.",
        "testStrategy": "Run the lint script on the codebase (once files exist) to ensure it passes without errors based on the configuration.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Configure Jest and ts-jest for Testing",
        "description": "Configure Jest and ts-jest for running tests on the TypeScript codebase.",
        "details": "Install Jest, ts-jest, and `@types/jest`. Configure Jest via `jest.config.js` to use ts-jest for `.ts` files. Add test scripts to `package.json`.",
        "testStrategy": "Write and run a simple test file (`.test.ts`) to confirm Jest and ts-jest execute correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Custom Error Classes (MoneyParseError, ValueOverflowError)",
        "description": "Implement custom error classes `MoneyParseError` and `ValueOverflowError`.",
        "details": "Define `MoneyParseError` and `ValueOverflowError` classes extending the built-in `Error` class. Include relevant properties or messages as needed for helpful errors.",
        "testStrategy": "Write simple unit tests to instantiate the error classes and verify their properties and inheritance.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate currency-codes and Implement Data Loading",
        "description": "Integrate the `currency-codes` package and implement logic to load and lookup currency data.",
        "details": "Install `currency-codes`. Implement a module to import and access currency data from the package. Consider how tree-shaking might be applied or if a custom JSON build step is needed later (optional for MVP).\n<info added on 2025-06-22T05:45:04.561Z>\nImplementation plan:\n1. Create `src/currencyData.ts` module that imports the `currency-codes` package once and exposes lightweight lookup helpers:\n   - `getCurrencyByCode(code: string)` returns the matching currency entry or null.\n   - `getCurrencyByNumber(number: string)` returns entry or null.\n   - `getAllCurrencies()` returns the raw array for advanced use.\n   These helpers provide a simple, typed facade so the rest of the parser doesn’t touch the large `currency-codes` dataset directly. No symbol mapping yet – that belongs to later pattern-parsing tasks.\n2. Add minimal internal interface `CurrencyInfo` to capture the subset of fields we actually use (`code`, `currency`, `number`, `countries`).  Casting is fine for now; we avoid shipping any runtime wrappers so tree-shaking works.\n3. Write Jest unit tests in `test/currencyData.test.ts` that assert USD/EUR lookups work by both code and numeric ID.  This covers the success path and gives us a red flag if the package structure changes.\n4. Dependency is already declared in `package.json`; no further install step needed.\n5. No public API exposure yet – `index.ts` will re-export once the core parser is wired up.\n\nThese changes are self-contained and unblock downstream tasks that rely on currency data lookups.\n</info added on 2025-06-22T05:45:04.561Z>",
        "testStrategy": "Write unit tests to verify currency data can be loaded and specific currency codes/symbols can be looked up correctly using the implemented logic.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Core Regex Pipeline Structure",
        "description": "Implement the core structure for the regex pipeline that processes input strings.",
        "details": "Create a module or class to manage the sequence of regex checks: currency detection -> numeric/word detection -> pattern-specific parsing. Design the flow for applying these steps to an input string.",
        "testStrategy": "Create a mock pipeline with simple regex steps and verify that an input string is processed through the defined sequence.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Currency-First Detection Regex",
        "description": "Implement the currency-first detection regex logic within the pipeline.",
        "details": "Develop regex patterns to quickly scan for ISO-4217 keywords or symbols using the loaded currency data. Integrate this as the first step in the regex pipeline.",
        "testStrategy": "Write unit tests with various inputs containing currency symbols or codes (e.g., '$', 'USD', '€', 'GBP') to verify the currency detection regex correctly identifies potential currency indicators.",
        "priority": "high",
        "dependencies": [
          7,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Numeric/Word Detection Regex",
        "description": "Implement the numeric/word detection regex logic within the pipeline.",
        "details": "Develop regex patterns to identify potential numeric or worded number parts of the input string. Integrate this step after currency detection in the pipeline.",
        "testStrategy": "Write unit tests with inputs containing numbers (plain, with separators), worded numbers ('one hundred'), and numeric-word combos ('10k') to verify the numeric/word detection regex correctly identifies these parts.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Parser for Plain Numbers Pattern",
        "description": "Implement the pattern parser for Plain Numbers (e.g., '123').",
        "details": "Create a specific parser function or module for the 'Plain Numbers' pattern. This parser should take a matched substring and convert it to a numeric value.",
        "testStrategy": "Write unit tests with various plain number strings ('1', '123', '999999') to verify the parser correctly extracts and converts the numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Parser for Numbers with Separators Pattern",
        "description": "Implement the pattern parser for Numbers with Separators (e.g., '1,234.56').",
        "details": "Create a parser for numbers including thousands separators (',') and decimal points ('.'). Handle different separator conventions if necessary (though PRD doesn't specify locales yet, focus on common ones).",
        "testStrategy": "Write unit tests with strings like '1,000', '1.23', '1,234,567.89' to verify the parser correctly handles separators and converts to the correct numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create regex pattern for numbers with separators",
            "description": "Define regex pattern to match numbers with thousands separators (,) and decimal points (.)",
            "details": "Pattern should handle: 1,000 | 1,234.56 | 1,234,567.89 | Handle edge cases like leading zeros, multiple decimals",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 2,
            "title": "Implement parser function for numbers with separators",
            "description": "Create parser that removes separators and converts to numeric value",
            "details": "Strip commas, validate format, convert to number, handle invalid inputs",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 3,
            "title": "Write unit tests for numbers with separators",
            "description": "Create comprehensive test suite for the parser",
            "details": "Test cases: '1,000', '1.23', '1,234,567.89', edge cases, invalid formats",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 4,
            "title": "Integrate pattern into main parser pipeline",
            "description": "Add the new pattern to the regex pipeline in index.ts",
            "details": "Export pattern, add to pipeline, ensure proper ordering",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 5,
            "title": "Run tests and verify implementation",
            "description": "Execute test suite and validate all cases pass",
            "details": "Run jest tests, fix any failures, ensure no regressions",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Parser for Symbols Pattern",
        "description": "Implement the pattern parser for Symbols (e.g., '$100').",
        "details": "Create a parser that recognizes currency symbols attached to numbers. Use the currency data to map symbols to ISO codes.",
        "testStrategy": "Write unit tests with strings like '$100', '€50', '£20.50' to verify the parser correctly identifies the symbol, extracts the number, and maps the symbol to the correct ISO currency code.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Parser for Abbreviations Pattern",
        "description": "Implement the pattern parser for Abbreviations (e.g., 'USD 100').",
        "details": "Create a parser that recognizes ISO 4217 currency abbreviations preceding or following a number. Use the currency data for lookup.",
        "testStrategy": "Write unit tests with strings like 'USD 100', 'EUR 50', 'GBP 20.50', '100 CAD' to verify the parser correctly identifies the abbreviation, extracts the number, and maps the abbreviation to the correct ISO currency code.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Parser for Worded Numbers Pattern",
        "description": "Implement the pattern parser for Worded Numbers (e.g., 'one hundred dollars').",
        "details": "Create a parser that converts worded numbers (e.g., 'one', 'ten', 'hundred', 'thousand', 'million') into their numeric equivalents.",
        "testStrategy": "Write unit tests with strings like 'one', 'twenty', 'one hundred', 'two thousand', 'one million' to verify the parser correctly converts the worded number to a numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Parser for Fractional Worded Numbers Pattern",
        "description": "Implement the pattern parser for Fractional Worded Numbers (e.g., 'half a dollar').",
        "details": "Create a parser that handles fractional worded numbers like 'half', 'quarter', etc., potentially combined with currency.",
        "testStrategy": "Write unit tests with strings like 'half a dollar', 'quarter pound' (if applicable, focus on monetary context) to verify correct numeric conversion.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define fractional word lexicon and normalization rules",
            "description": "List supported fractional terms (e.g., half, quarter, three quarters, third/thirds) and map them to numeric values for monetary parsing. Clarify scope and assumptions.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 2,
            "title": "Implement fractional worded number parser",
            "description": "Add parser logic that converts supported fractional word patterns into numeric amounts and currency metadata, aligning with existing pattern/parser interfaces.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 3,
            "title": "Integrate parser into pipeline",
            "description": "Register the fractional worded number pattern/parser in the regex pipeline and ensure ordering doesn’t conflict with existing worded-number handling.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 4,
            "title": "Write unit tests for fractional worded numbers",
            "description": "Add fixtures covering phrases like 'half a dollar', 'quarter dollar', 'three quarters of a euro', verifying numeric conversion and currency handling.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Parser for Numeric-Word Combos Pattern",
        "description": "Implement the pattern parser for Numeric-Word Combos (e.g., '10k').",
        "details": "Create a parser that handles combinations of numbers and words representing magnitude (e.g., 'k', 'm', 'bn').",
        "testStrategy": "Write unit tests with strings like '10k', '5m', '2bn' to verify the parser correctly calculates the numeric value (10,000, 5,000,000, 2,000,000,000).",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Parser for Slang Terms Pattern",
        "description": "Implement the pattern parser for Slang Terms (e.g., 'buck', 'quid').",
        "details": "Create a parser that recognizes common slang terms for currency units and maps them to the appropriate currency and value.",
        "testStrategy": "Write unit tests with strings like 'buck', 'quid', 'fiver', 'tenner' to verify the parser correctly identifies the slang term and associated value/currency (assuming US/UK context based on examples).",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Parser for Contextual Phrases Pattern",
        "description": "Implement the pattern parser for Contextual Phrases (e.g., 'a hundred dollars') including compound major+minor currency expressions.",
        "status": "done",
        "dependencies": [
          7,
          9
        ],
        "priority": "medium",
        "details": "Create a parser that handles numbers and currencies embedded within simple phrases, potentially including articles ('a', 'the'), and now also handles compound major+minor currency expressions (e.g., 'a dollar and 23 cents', 'five euros and fifty cents').",
        "testStrategy": "Write unit tests with strings like 'a hundred dollars', 'the fifty euros', 'a dollar and 23 cents', 'five euros and fifty cents' to verify the parser extracts the core monetary expression, including major and minor units.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design contextual phrases parsing rules and data shapes",
            "description": "Define input examples, expected outputs, and parser interface for contextual phrases (articles + number + currency).",
            "status": "done",
            "dependencies": [],
            "details": "List target patterns (e.g., 'a hundred dollars', 'the fifty euros', 'one thousand yen'); clarify assumptions on article handling and ordering; update task notes if scope adjustments needed.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement contextual phrase parser",
            "description": "Code parser to extract amount and currency from phrases with articles and simple structure.",
            "status": "done",
            "dependencies": [],
            "details": "Handle patterns like '<article?> <number/worded number> <currency name/code>'; normalize case/whitespace; return amount+currency; reuse existing number and currency helpers where possible.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate parser into pipeline",
            "description": "Wire contextual phrase matching into regex/numeric pipeline with appropriate precedence.",
            "status": "done",
            "dependencies": [],
            "details": "Add matching function and hook into regexPipeline step order; ensure no regressions with other patterns.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add unit tests for contextual phrases",
            "description": "Write tests for parsing phrases like 'a hundred dollars', 'the fifty euros', 'one thousand yen'.",
            "status": "done",
            "dependencies": [],
            "details": "Cover articles, numeric/worded amounts, case/whitespace handling, invalid inputs, and pipeline integration where applicable.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Documentation and edge-case notes",
            "description": "Document supported contextual phrase patterns and limitations.",
            "status": "done",
            "dependencies": [],
            "details": "Update README or pattern docs with examples; note assumptions (articles optional, simple ordering, no complex grammar).",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Extend parser to handle major+minor currency expressions",
            "description": "Modify the parser to recognize and extract amounts from phrases like 'a dollar and 23 cents'.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Implement parsing logic for '<major currency> and <minor currency>' patterns. Ensure correct handling of different currencies and their minor units. Consider edge cases like missing major or minor units.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Update unit tests for major+minor currency expressions",
            "description": "Add new unit tests to cover the parsing of major+minor currency expressions.",
            "status": "done",
            "dependencies": [
              4,
              6
            ],
            "details": "Include tests for various scenarios, such as 'a dollar and 23 cents', 'five euros and fifty cents', '10 pounds and 5 pence', and edge cases with missing major or minor units.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Update documentation with major+minor currency examples",
            "description": "Expand the documentation to include examples and explanations of how the parser handles major+minor currency expressions.",
            "status": "done",
            "dependencies": [
              5,
              6
            ],
            "details": "Add examples to the README or pattern docs demonstrating the supported formats and limitations for major+minor currency parsing.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 19,
        "title": "Implement Parser for Regional Formats Pattern",
        "description": "Implement the pattern parser for Regional Formats (e.g., '1.234,56 €').",
        "details": "Create a parser that handles regional variations in number formatting (decimal/thousands separators) and currency symbol/code placement.",
        "testStrategy": "Write unit tests with strings like '1.234,56 €', '€ 1.234,56', '5,678.90 $' to verify the parser correctly handles regional formatting and currency association.",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Regional Format Specifications",
            "description": "Document the different regional formats to be supported, including variations in decimal separators, thousands separators, currency symbols, currency codes, and their placement (prefix/suffix).",
            "dependencies": [],
            "details": "Create a comprehensive list of regional format examples and their corresponding parsing rules. Consider edge cases and ambiguous formats.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Decimal and Thousands Separator Detection",
            "description": "Develop logic to automatically detect the decimal and thousands separators used in a given input string based on regional format specifications.",
            "dependencies": [
              1
            ],
            "details": "Implement algorithms to identify the separators based on frequency and position within the input string. Handle cases where separators are missing or ambiguous.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Currency Symbol/Code Extraction",
            "description": "Develop logic to extract the currency symbol or code from the input string, considering both prefix and suffix placement.",
            "dependencies": [
              1
            ],
            "details": "Implement pattern matching or regular expressions to identify and extract the currency symbol or code. Handle cases where the currency symbol/code is missing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Number Parsing with Regional Format Handling",
            "description": "Implement the core number parsing logic, taking into account the detected decimal and thousands separators, and the extracted currency symbol/code.",
            "dependencies": [
              2,
              3
            ],
            "details": "Convert the input string into a numerical value, correctly interpreting the separators and currency information. Handle potential parsing errors and invalid formats.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Validation and Error Handling",
            "description": "Implement validation checks to ensure the input string conforms to a valid regional format and handle potential parsing errors gracefully.",
            "dependencies": [
              4
            ],
            "details": "Add checks for invalid characters, incorrect separator placement, and other format inconsistencies. Provide informative error messages for invalid inputs.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Currency Normalisation",
        "description": "Implement currency normalisation logic using the `currency-codes` dataset.",
        "details": "Create a function or module to take a potential currency identifier (symbol, code, name) and normalize it to an ISO 4217 code using the `currency-codes` data.",
        "testStrategy": "Write unit tests with various inputs ('$', 'USD', 'Euro', 'GBP') to verify they are correctly normalized to their ISO 4217 codes ('USD', 'EUR', 'GBP'). Test cases for unknown currencies should result in an error or null/undefined output depending on implementation.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement parseMoney Function",
        "description": "Implement the `parseMoney` function, integrating the regex pipeline, pattern parsers, currency normalization, and error handling.",
        "details": "Create the `parseMoney(input: string, opts?: ParseOptions): ParseResult | null` function. This function should orchestrate the regex pipeline, apply pattern parsers to matches, normalize the currency, and return the `ParseResult` object or `null` if no match is found. Handle the `defaultCurrency` and `strict` options.",
        "testStrategy": "Write integration tests covering various input strings and options (`defaultCurrency`, `strict`) to verify correct parsing, currency normalization, and the structure of the returned `ParseResult` object or `null`.",
        "priority": "high",
        "dependencies": [
          5,
          7,
          8,
          9,
          20,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement parseAll Function",
        "description": "Implement the `parseAll` function to find all monetary expressions in a string.",
        "details": "Create the `parseAll(input: string, opts?: ParseOptions): ParseResult[]` function. This function should iterate through the input string, potentially using the `parseMoney` logic or a variation of the pipeline, to find all occurrences of monetary expressions and return an array of `ParseResult` objects.",
        "testStrategy": "Write integration tests with strings containing multiple monetary expressions (e.g., 'I have $100 and he has €50') to verify all instances are found and parsed correctly into an array of `ParseResult` objects.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Value Overflow Check and Error",
        "description": "Implement the check for numeric value exceeding `Number.MAX_SAFE_INTEGER` and throw `ValueOverflowError`.",
        "details": "Within the parsing logic (likely in individual parsers or the final value conversion step), add a check to compare the resulting numeric amount against `Number.MAX_SAFE_INTEGER`. If it exceeds this limit, throw a `ValueOverflowError`.",
        "testStrategy": "Write unit or integration tests with inputs representing numbers larger than `Number.MAX_SAFE_INTEGER` (e.g., '9007199254740992', '10 quadrillion') to verify that a `ValueOverflowError` is correctly thrown.",
        "priority": "high",
        "dependencies": [
          5,
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Write Unit Tests for Pattern Parsers (Fixtures)",
        "description": "Write comprehensive unit tests for each of the 10 pattern parsers using specific fixtures.",
        "details": "Create test files for each pattern parser. Use representative input strings (fixtures) covering various valid cases and edge cases for each pattern. Verify the parser correctly extracts the numeric value and any associated currency information.",
        "testStrategy": "Run Jest tests for all pattern parsers. Ensure tests cover a wide range of fixtures and achieve high code coverage for the parser logic.",
        "priority": "high",
        "dependencies": [
          4,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Testing Environment",
            "description": "Configure pytest and any necessary testing libraries.",
            "dependencies": [],
            "details": "Install pytest, create a pytest.ini file, and set up any required test directories.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Fixtures Directory",
            "description": "Establish a directory to store fixture data for the pattern parsers.",
            "dependencies": [
              1
            ],
            "details": "Create a 'fixtures' directory within the test directory structure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Define Fixtures for Parser 1",
            "description": "Create fixture data representing various valid and invalid inputs for the first pattern parser.",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parser 1.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Write Unit Tests for Parser 1",
            "description": "Implement pytest unit tests for the first pattern parser, utilizing the defined fixtures.",
            "dependencies": [
              3
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parser 1.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Define Fixtures for Parser 2",
            "description": "Create fixture data representing various valid and invalid inputs for the second pattern parser.",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parser 2.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Write Unit Tests for Parser 2",
            "description": "Implement pytest unit tests for the second pattern parser, utilizing the defined fixtures.",
            "dependencies": [
              5
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parser 2.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Define Fixtures for Parsers 3-10",
            "description": "Create fixture data representing various valid and invalid inputs for the remaining pattern parsers (3-10).",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parsers 3 through 10.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Write Unit Tests for Parsers 3-10",
            "description": "Implement pytest unit tests for the remaining pattern parsers (3-10), utilizing the defined fixtures.",
            "dependencies": [
              7
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parsers 3 through 10.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Run All Unit Tests",
            "description": "Execute all the created unit tests to ensure proper functionality.",
            "dependencies": [
              4,
              6,
              8
            ],
            "details": "Use pytest to run all tests in the test suite.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Analyze Test Results and Refactor",
            "description": "Review the test results, identify any failures, and refactor code or tests as needed.",
            "dependencies": [
              9
            ],
            "details": "Address any failing tests by debugging the pattern parsers or adjusting the test fixtures.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 25,
        "title": "Write Unit Tests for API Functions and Errors",
        "description": "Write unit tests for the public API functions (`parseMoney`, `parseAll`) including error handling cases.",
        "details": "Create test files for `parseMoney` and `parseAll`. Test various valid inputs, inputs with no matches, inputs triggering `MoneyParseError` (e.g., unknown currency with `strict: true`), and inputs triggering `ValueOverflowError`. Verify return values and thrown errors.",
        "testStrategy": "Run Jest tests for the API functions. Ensure tests cover successful parsing, null results, and all specified error conditions.",
        "priority": "high",
        "dependencies": [
          4,
          21,
          22,
          23
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Expand parseMoney tests for input patterns",
            "description": "Add tests to parseMoney.test.ts to cover various input patterns including symbols, ISO codes, worded numbers, and slang.",
            "dependencies": [],
            "details": "Focus on creating a diverse set of test cases that represent common and uncommon money representations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Test parseMoney edge cases",
            "description": "Add tests to parseMoney.test.ts to cover edge cases such as empty string, no match, and whitespace inputs.",
            "dependencies": [],
            "details": "Ensure that parseMoney handles these edge cases gracefully and returns the expected results or errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement ValueOverflowError testing for parseMoney",
            "description": "Add tests to parseMoney.test.ts to specifically test the ValueOverflowError when parsing extremely large numbers.",
            "dependencies": [],
            "details": "Create test cases that intentionally cause a value overflow and verify that the correct error is thrown.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Verify parseMoney return value structure",
            "description": "Add tests to parseMoney.test.ts to verify the structure of the return value, ensuring it contains the expected properties and data types.",
            "dependencies": [],
            "details": "Check that the returned object has the correct fields (e.g., amount, currency) and that their types are as expected.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement ValueOverflowError testing for parseAll",
            "description": "Add tests to parseAll.test.ts to specifically test the ValueOverflowError when parsing extremely large numbers within text.",
            "dependencies": [],
            "details": "Create test cases with large numbers embedded in text and verify that the correct error is thrown when parsing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Verify parseAll edge cases",
            "description": "Add tests to parseAll.test.ts to cover edge cases and ensure robust handling of unexpected inputs.",
            "dependencies": [],
            "details": "Focus on scenarios where the input might be malformed or incomplete, ensuring the function behaves predictably.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Property-Based Fuzzing Tests (fast-check)",
        "description": "Implement property-based fuzzing tests using `fast-check` to improve test coverage and robustness.",
        "details": "Install `fast-check`. Write property-based tests that generate random strings or structured inputs and pass them to `parseMoney` or `parseAll`. Define properties that the output should satisfy (e.g., if a number is clearly present, the amount should be numeric).",
        "testStrategy": "Run the property-based tests with a sufficient number of iterations. Analyze any failing cases to identify bugs or missing pattern handling.",
        "priority": "medium",
        "dependencies": [
          4,
          21,
          22
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install fast-check dependency",
            "description": "Install the fast-check library as a development dependency using npm or yarn.",
            "dependencies": [],
            "details": "Use `npm install --save-dev fast-check` or `yarn add --dev fast-check`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create test file structure and basic setup",
            "description": "Create a test file (e.g., `parseMoney.test.ts`) and import necessary modules from fast-check and the code to be tested.",
            "dependencies": [
              1
            ],
            "details": "Create a new test file and import `fc` from 'fast-check' and the `parseMoney` and `parseAll` functions from your codebase.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement property tests for parseMoney with random string inputs",
            "description": "Define properties for `parseMoney` that should hold true for any random string input. Focus on error handling and invariant checks.",
            "dependencies": [
              2
            ],
            "details": "Use `fc.string()` to generate random string inputs and assert that `parseMoney` either throws an error or returns a valid result based on the input string's format.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement property tests for parseAll with structured monetary inputs",
            "description": "Define properties for `parseAll` using structured monetary inputs (e.g., objects with amount and currency fields).",
            "dependencies": [
              2
            ],
            "details": "Create custom arbitraries using `fc.record` to generate structured monetary inputs. Assert that `parseAll` correctly parses these inputs and maintains expected invariants.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add edge case generators and invariant tests",
            "description": "Extend the generators to include edge cases (e.g., very large numbers, special characters) and add more comprehensive invariant tests to ensure the parsing functions behave correctly under all circumstances.",
            "dependencies": [
              3,
              4
            ],
            "details": "Use `fc.oneof` or `fc.frequency` to combine standard generators with generators for edge cases. Add assertions to verify that invariants related to the parsed values hold true.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 27,
        "title": "Configure Dual ESM/CJS Build Process",
        "description": "Configure the build process to generate dual ESM and CJS outputs from the TypeScript source.",
        "details": "Use the configured `tsconfig.json` and potentially a build tool (like Rollup or Webpack, though TS compiler might suffice) to produce separate ESM and CJS bundles or file structures in the output directory.\n<info added on 2025-06-29T17:03:14.182Z>\nImplementation plan (initial) for Dual ESM/CJS build:\n1. Add `tsconfig.cjs.json` extending base tsconfig but overriding:\n   {\n     \"extends\": \"./tsconfig.json\",\n     \"compilerOptions\": {\n       \"module\": \"CommonJS\",\n       \"outDir\": \"dist/cjs\"\n     }\n   }\n2. Retain `tsconfig.json` with ESNext module and `dist/esm` outDir.\n3. Update `package.json`:\n   - Add scripts:\n     \"clean\": \"rimraf dist\",\n     \"build:esm\": \"tsc -p tsconfig.json\",\n     \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n     \"build\": \"npm run clean && npm run build:esm && npm run build:cjs\".\n   - Add `exports` field for conditional exports:\n     {\n       \"import\": \"./dist/esm/index.js\",\n       \"require\": \"./dist/cjs/index.js\"\n     }\n   - Set `main`: \"./dist/cjs/index.js\",\n     `module`: \"./dist/esm/index.js\",\n     `types`: \"./dist/esm/index.d.ts\".\n4. Install `rimraf` as devDependency.\n5. Optionally configure `typesVersions` mapping for older TS consumers (skip for now).\n6. Verify build by running `npm run build` producing both directories and test require/import in node.\n\nNext steps:\n- Create tsconfig.cjs.json file.\n- Modify package.json scripts and exports.\n- Install rimraf.\n- Run build and adjust tests.\n- Update documentation if needed.\n</info added on 2025-06-29T17:03:14.182Z>",
        "testStrategy": "Verify the output directory contains both ESM and CJS versions of the library files. Test importing the library in a simple Node.js script using both `require()` (CJS) and `import()` (ESM).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Configure UMD Bundle Generation for Demo Site",
        "description": "Configure the build process to generate a separate minified UMD bundle specifically for the demo site.",
        "details": "Use a bundler (like Rollup or Webpack) to create a single minified UMD file from the library source. This bundle should be suitable for inclusion via a `<script>` tag.",
        "testStrategy": "Verify a single minified UMD file is generated. Create a simple HTML file with a `<script>` tag pointing to the UMD file and verify the library's public API is available on the global scope (e.g., `window.monetJs.parseMoney`).",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Configure GitHub Actions CI Pipeline (Lint, Test, Build)",
        "description": "Configure the GitHub Actions CI pipeline to run linting, testing, and building steps.",
        "details": "Create a GitHub Actions workflow file (`.github/workflows/ci.yml`). Define jobs for linting (Task 3), testing (Task 4), and building (Task 27). Configure the workflow to trigger on pushes and pull requests.",
        "testStrategy": "Push code to a GitHub repository to trigger the CI workflow. Verify that all steps (lint, test, build) pass successfully in the CI environment.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Add Size-Limit Check to CI Pipeline",
        "description": "Add a size-limit check to the CI pipeline to gate bundle size (<5 kB gzip).",
        "details": "Install `size-limit`. Configure `size-limit` to check the gzip size of the main library bundle(s). Add a step to the CI workflow to run the size-limit check.",
        "testStrategy": "Run the CI workflow. Verify the size-limit check is executed and passes, ensuring the bundle size remains below the specified threshold.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Set up Changesets for Automated Releases",
        "description": "Set up Changesets for automated semantic versioning and release management.",
        "details": "Install Changesets CLI. Run `changeset init` to set up the necessary files. Document the process for adding changesets for future contributions.",
        "testStrategy": "Follow the Changesets workflow to create a changeset, run `changeset version`, and verify that version bumps and changelog entries are generated correctly.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Build Live Demo Website (Vite)",
        "description": "Build the live demo website using Vite, consuming the UMD bundle.",
        "details": "Set up a new project directory for the demo site (e.g., `demo`). Use Vite to serve static HTML, CSS, and minimal vanilla JS. The JS should import and use the generated UMD bundle of `numis` to provide real-time parsing functionality.\n<info added on 2025-07-01T09:29:55.720Z>\nClarification: The Vite demo should be an entirely separate project located in the `demo/` directory, with its own `package.json`, dependencies, and `vite.config.js`. The demo’s build/dev scripts must not run as part of the library’s main `build` or `prepare` steps. The root package remains focused solely on building the NPM package.\n\nImplementation adjustments:\n• All Vite config and dependencies live inside `demo/`.\n• Root `package.json` scripts only expose optional `dev:demo` and `build:demo` that delegate into `demo/` (e.g., `npm --prefix demo run dev`).\n• The existing library build/prepare flow remains unchanged.\n\nSubtasks 32.1–32.6 remain valid but implicitly operate within the isolated `demo/` project structure.\n</info added on 2025-07-01T09:29:55.720Z>",
        "testStrategy": "Run the Vite development server for the demo site. Open the site in a browser and verify that the `numis` library is loaded and the real-time parsing feature works as expected.",
        "priority": "medium",
        "dependencies": [
          28
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite project in demo directory",
            "description": "Create a new Vite project inside the existing demo/ folder, configured for vanilla JS.",
            "details": "1. Run `npm create vite@latest demo -- --template vanilla` in project root.\n2. Adjust Vite config/output paths if needed so assets build into demo/dist.\n3. Add script entries `dev:demo` and `build:demo` to package.json.\n4. Verify `npm run dev:demo` serves the demo site on localhost.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 2,
            "title": "Integrate numis UMD bundle",
            "description": "Add the generated numis UMD script into the Vite demo project.",
            "details": "1. Ensure the build step for numis UMD (Task 28) outputs `dist/umd/numis.min.js`.\n2. Copy or link the UMD file into demo/public (or use Vite static asset import).\n3. Include `<script src=\"/numis.min.js\"></script>` in `index.html` and verify `window.monetJs` exists.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 3,
            "title": "Implement Testing Area UI",
            "description": "Add a textarea/input and results panel so users can paste text and view parsed monetary data.",
            "details": "1. In `index.html`, create a `<textarea id=\"input\">` and a `<pre id=\"output\"></pre>`.\n2. Add a \"Parse\" button or use `input` event listener for real-time parsing.\n3. Basic styling: responsive layout, monospaced output block.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 4,
            "title": "Wire numis parsing logic",
            "description": "Hook up the UI to call numis parse function and display structured results.",
            "details": "1. In `main.js`, add event listener on textarea or button.\n2. Call `window.monetJs.parseMoney(text)`.\n3. Format returned object as JSON using `JSON.stringify(result,null,2)` and inject into `output` pre.\n4. Handle errors gracefully.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 5,
            "title": "Add styling and user experience polish",
            "description": "Refine CSS and interactions for the demo site.",
            "details": "1. Add basic CSS for layout, fonts, colors.\n2. Highlight parsed output (e.g., syntax highlighting via Prism.js optional).\n3. Ensure mobile responsiveness.\n4. Add footer with project link and version.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 6,
            "title": "Document build and deployment",
            "description": "Write README/demo docs explaining how to build and run the demo site locally or deploy to GitHub Pages.",
            "details": "1. Add section in root README or demo/README with commands `npm run build:demo` and `npm run dev:demo`.\n2. Provide instructions for GitHub Pages deployment via `vite build --base /monet/`.\n3. Include screenshot/gif of testing area in action.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 7,
            "title": "Upgrade demo to full Vite app with enhanced UI",
            "description": "Convert static demo into a small Vite application with modular JS and polished UI.",
            "details": "1. Move inline CSS into dedicated `style.css`, link it via <link>.\n2. Improve layout with flexbox, responsive design, and better typography/colors.\n3. Update `main.js` to parse on textarea input (debounced) and show results in real time; add error handling.\n4. Separate logic from markup for cleaner structure.\n5. Ensure zero external dependencies beyond Vite.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 8,
            "title": "Convert demo to Vite React app",
            "description": "Rebuild demo using Vite + React for richer example.",
            "details": "1. Add React, ReactDOM, and @vitejs/plugin-react as dependencies in demo/package.json.\n2. Update vite.config.js to use react plugin.\n3. Move UI into React components (App.jsx) with textarea, result panel.\n4. Render via main.jsx.\n5. Keep numis UMD bundle in public and access via window.monetJs.\n6. Style using existing CSS.\n7. Update README instructions.\n<info added on 2025-07-01T12:38:16.956Z>\n8. Import RegexPipeline from numis and use `new RegexPipeline().run()` instead of `parseMoney` (as `parseMoney` is not yet exported).\n</info added on 2025-07-01T12:38:16.956Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          }
        ]
      },
      {
        "id": 33,
        "title": "Configure GitHub Pages Deployment for Demo Site",
        "description": "Configure GitHub Pages deployment for the demo website via GitHub Actions.",
        "details": "Update the GitHub Actions workflow or create a new one to build the demo site (Task 32) and deploy the output to GitHub Pages on pushes to a specific branch (e.g., `main` or `gh-pages`).",
        "testStrategy": "Push changes to trigger the deployment workflow. Verify that the demo site is successfully deployed and accessible via the GitHub Pages URL.",
        "priority": "medium",
        "dependencies": [
          29,
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Add Build Step to CI Pipeline",
        "description": "Reintroduce the 'npm run build' step into the GitHub Actions workflow (ci.yml) to ensure build artifacts are generated during CI runs.",
        "details": "Modify the '.github/workflows/ci.yml' file. Add a step that runs 'npm run build' after the linting and testing steps have successfully completed. Ensure the build command is correct and the step is named appropriately, e.g., 'Build Library'. This step should execute the build configurations defined in tasks 27 and 28.",
        "testStrategy": "Trigger the CI workflow by pushing a change or opening a pull request. Verify that the 'Build Library' step is executed in the workflow run and completes successfully without errors. Check the workflow logs to confirm the 'npm run build' command was run and produced the expected output artifacts.",
        "status": "done",
        "dependencies": [
          29,
          27,
          28
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Build Production Demo Using Published NPM Package",
        "description": "Create a production-ready demo that installs and uses the published numis package from npm.",
        "details": "This task should be completed after all other features are implemented and the package is published to npm. The demo should install the numis package from npm rather than using local imports, ensuring proper dependency resolution and demonstrating real-world usage. This approach will solve the current ESM import issues and provide a genuine showcase of how users would integrate the library.\n\nSteps:\n1. Publish the numis package to npm (either public or as a scoped package)\n2. Update the demo project to install the package from npm\n3. Modify imports in the demo to use the npm package rather than local paths\n4. Update the vite.config.js to remove the local path aliases\n5. Test the demo to ensure it works correctly with the published package\n6. Document the process in the README",
        "testStrategy": "Verify that the demo runs correctly with the published npm package. Ensure all features work as expected and that there are no dependency resolution issues.",
        "status": "done",
        "dependencies": [
          32
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Optimize numis for Demo and Bundle Size",
        "description": "Optimize numis for demo-ready one-call parsing with minimal bundle size. This includes lazy initialization, tree-shaking improvements, and updating demo usage to showcase the optimized library.",
        "details": "1.  **Lazy Initialization:** Implement lazy initialization for non-core components and parsers. This will reduce the initial bundle size by deferring the loading of less frequently used features until they are actually needed.\n2.  **Tree-Shaking Analysis:** Analyze the current bundle using a tree-shaking analyzer (e.g., webpack-bundle-analyzer) to identify opportunities for further size reduction.  Focus on removing dead code and ensuring that only necessary modules are included in the final bundle.\n3.  **Code Splitting:** Explore code splitting strategies to further reduce the initial load time.  Consider splitting the bundle into smaller chunks based on functionality or usage patterns.\n4.  **Dependency Optimization:** Review and update dependencies to ensure they are the latest versions and that they are not contributing unnecessarily to the bundle size.  Consider replacing larger dependencies with smaller, more focused alternatives where appropriate.\n5.  **Demo Update:** Update the demo to showcase the optimized library and its one-call parsing capabilities.  Ensure the demo is easy to use and provides clear examples of how to use the library effectively.\n6.  **Documentation:** Update documentation to reflect the changes made during optimization, including any new APIs or usage patterns.",
        "testStrategy": "1.  **Bundle Size Verification:** Measure the bundle size before and after optimization to ensure that the changes have resulted in a significant reduction in size.  Use tools like webpack-bundle-analyzer to compare the bundle contents.\n2.  **Performance Testing:** Conduct performance testing to ensure that the optimizations have not negatively impacted the parsing speed or overall performance of the library.  Focus on testing the one-call parsing functionality with a variety of inputs.\n3.  **Functional Testing:** Run existing unit tests to ensure that all existing functionality continues to work as expected after the optimizations.\n4.  **Demo Testing:** Thoroughly test the updated demo to ensure that it is easy to use, provides clear examples, and accurately showcases the optimized library.\n5.  **Tree-Shaking Verification:** Verify that tree-shaking is working correctly by inspecting the generated bundle and ensuring that unused code has been removed.",
        "status": "done",
        "dependencies": [
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add one-call parseMoney API",
            "description": "Expose a top-level parseMoney(text) that wraps RegexPipeline.default().run and returns structured output.",
            "details": "Maintain default all-pattern coverage; keep RegexPipeline export for advanced use.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 2,
            "title": "Make heavy initializations lazy/memoized",
            "description": "Defer currency name/code map construction and other heavy lookups until first call to reduce bundle impact.",
            "details": "Ensure contextual phrases and regex pipeline build maps on demand; keep behavior identical.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 3,
            "title": "Centralize currency map building",
            "description": "Build currency name/code maps once in a shared helper to avoid duplicate currency-codes pulls across modules.",
            "details": "Ensure both regex pipeline and contextual phrases reuse the same lazy map builder to minimize bundle size.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 4,
            "title": "Add browser-friendly entry + demo import",
            "description": "Expose a clear ESM entry (e.g., parseMoney) for Vite/React demo and update demo to consume it.",
            "details": "Keep all patterns active by default; ensure demo import path uses published package entry and benefits from tree-shaking.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "Implement Example Prompts UI Component",
        "description": "Create a UI component for the demo website that displays random example monetary expressions, allowing users to populate the input field with a click.",
        "details": "1.  Create a new UI component (e.g., `ExamplePrompts.vue` or `example-prompts.js`) within the Vite demo project.\n2.  Define an array of diverse example monetary expressions (strings) covering various patterns (symbols, abbreviations, worded numbers, regional formats, etc.). Aim for at least 10-15 examples.\n3.  Implement logic to randomly select 3 examples from the array when the component is mounted or refreshed.\n4.  Display the selected examples as clickable elements (e.g., buttons or styled divs).\n5.  Attach a click event listener to each example element. When clicked, the selected example should populate the main input field of the demo website.\n6.  Style the component to visually integrate with the existing demo website design.\n7.  Ensure the component is responsive and works well on different screen sizes.\n8.  Consider adding a \"Refresh Examples\" button to allow users to generate a new set of random examples.\n9.  The example prompts should cover a range of currency formats and amounts to showcase the parser's capabilities. Examples: [\"$100\", \"EUR 50\", \"GBP 20.50\", \"100 CAD\", \"one hundred dollars\", \"half a dollar\", \"10k\", \"1.234,56 €\", \"buck\", \"1,000,000\", \"USD 12.50\", \"£1000\", \"5m\", \"quarter pound\"]",
        "testStrategy": "1.  Verify that the Example Prompts component is displayed correctly on the demo website.\n2.  Confirm that 3 random examples are displayed each time the component is loaded or refreshed (if a refresh button is implemented).\n3.  Click each example prompt and verify that the corresponding text is correctly populated into the main input field of the demo website.\n4.  Test with different screen sizes to ensure the component is responsive and the examples are displayed correctly.\n5.  Check that the example prompts cover a variety of currency formats and amounts.\n6.  Manually test a large number of example selections to ensure randomness and that no errors occur.",
        "status": "done",
        "dependencies": [
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          32
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Example Monetary Expressions",
            "description": "Create an array of diverse example monetary expressions (strings) covering various patterns (symbols, abbreviations, worded numbers, regional formats, etc.). Aim for at least 15 examples.",
            "dependencies": [],
            "details": "Create a `const` array named `examplePrompts` in a new file (e.g., `src/components/examplePromptsData.js`). This array should contain strings representing monetary amounts in various formats. Include examples like: ['$100', 'EUR 50', 'GBP 20.50', '100 CAD', 'one hundred dollars', 'half a dollar', '10k', '1.234,56 €', 'buck', '1,000,000', 'USD 12.50', '£1000', '5m', 'quarter pound', '20 quid']. Export the array.",
            "status": "done",
            "testStrategy": "Manually inspect the `examplePromptsData.js` file to ensure the array contains a diverse set of monetary expressions."
          },
          {
            "id": 2,
            "title": "Build Example Prompts Component",
            "description": "Create a new UI component (e.g., `ExamplePrompts.vue` or `example-prompts.js`) within the Vite demo project. This component will display the example prompts.",
            "dependencies": [],
            "details": "Create a new Vue component file (e.g., `src/components/ExamplePrompts.vue`). Import the `examplePrompts` array from `src/components/examplePromptsData.js`. In the component's `data` or `reactive` section, create a variable to hold the randomly selected prompts. Implement a method to randomly select 3 examples from the `examplePrompts` array when the component is mounted or when a 'Refresh Examples' button is clicked. Display the selected examples as clickable elements (e.g., buttons or styled divs).",
            "status": "done",
            "testStrategy": "Verify that the component renders without errors and displays 3 example prompts from the array. Check that the prompts are different each time the component is mounted or refreshed."
          },
          {
            "id": 3,
            "title": "Implement Click Handler",
            "description": "Attach a click event listener to each example element. When clicked, the selected example should populate the main input field of the demo website.",
            "dependencies": [],
            "details": "In the `ExamplePrompts.vue` component, add a click event listener to each clickable example element. The click handler should retrieve the text content of the clicked element and use it to update the value of the main input field in the parent component. Use Vue's event emission (`$emit`) to communicate the selected example to the parent component. The parent component should then update the input field.",
            "status": "done",
            "testStrategy": "Click each example prompt and verify that the main input field is populated with the corresponding text. Ensure that the input field is updated correctly for all example prompts."
          },
          {
            "id": 4,
            "title": "Style the Example Prompts Component",
            "description": "Style the component to visually integrate with the existing demo website design. Ensure the component is responsive and works well on different screen sizes.",
            "dependencies": [],
            "details": "Apply CSS styles to the `ExamplePrompts.vue` component to match the overall design of the demo website. Use CSS classes or inline styles to format the example prompts, the 'Refresh Examples' button (if implemented), and the container element. Ensure the component is responsive by using media queries or a responsive CSS framework (e.g., Bootstrap, Tailwind CSS).",
            "status": "done",
            "testStrategy": "Inspect the component in different browsers and screen sizes to ensure it is visually appealing and responsive. Verify that the styles are consistent with the rest of the demo website."
          },
          {
            "id": 5,
            "title": "Integrate and Test the Feature",
            "description": "Integrate the Example Prompts component into the main demo website and test the complete feature.",
            "dependencies": [],
            "details": "Import the `ExamplePrompts.vue` component into the main demo website component. Place the component in a suitable location on the page. Implement the logic in the parent component to receive the selected example from the `ExamplePrompts` component and update the input field accordingly. Test the entire feature by clicking on the example prompts and verifying that the input field is updated correctly. Test the 'Refresh Examples' button (if implemented) to ensure it generates new random examples.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing of the feature by interacting with the Example Prompts component and verifying that the input field is updated correctly. Test the feature on different browsers and screen sizes. Verify that the 'Refresh Examples' button (if implemented) works as expected."
          }
        ]
      },
      {
        "id": 38,
        "title": "Implement Custom Default Currency for parseMoney()",
        "description": "Add a custom default currency option to the numis SDK's parseMoney() function, allowing users to specify a fallback currency when none is detected in the input text.",
        "details": "1.  **Create ParseOptions Interface:** Define a `ParseOptions` interface with an optional `defaultCurrency` field (string, ISO-4217 code). The default value should be 'USD' for backwards compatibility.\n2.  **Update parseMoney() Signature:** Modify the `parseMoney()` function signature to accept an optional `options` parameter of type `ParseOptions`.\n3.  **Modify RegexPipeline:** Update the RegexPipeline to propagate the `defaultCurrency` option. If no currency is detected by the regex, apply the `defaultCurrency` from the options.\n4.  **Currency Code Validation:** Validate the `defaultCurrency` code against the `currency-codes` package to ensure it's a valid ISO-4217 currency code. Throw a `MoneyParseError` if the code is invalid.\n5.  **Update README Documentation:** Add examples to the README demonstrating how to use the `defaultCurrency` option.\n6.  **Demo Website Integration:** Add a currency dropdown selector to the demo website (`demo/src/App.jsx`) allowing users to select a default currency and see its effect on parsing. The dropdown should be populated with common currencies (USD, EUR, GBP, etc.).\n\nExample Code:\n\n```typescript\ninterface ParseOptions {\n  defaultCurrency?: string;\n}\n\nfunction parseMoney(text: string, options?: ParseOptions): Money | undefined {\n  const defaultCurrency = options?.defaultCurrency ?? 'USD';\n  // ... rest of the parsing logic\n}\n```",
        "testStrategy": "1.  **Unit Tests:**\n    *   Write unit tests for `parseMoney()` with different `defaultCurrency` options (e.g., 'EUR', 'GBP', 'JPY').\n    *   Verify that the correct currency is returned when no currency is detected in the input text and a `defaultCurrency` is provided.\n    *   Verify that the default currency is 'USD' when no options are provided.\n    *   Write a unit test to ensure that an invalid currency code passed as `defaultCurrency` throws a `MoneyParseError`.\n2.  **Demo Website Testing:**\n    *   Verify that the currency dropdown selector is displayed correctly on the demo website.\n    *   Verify that selecting a currency from the dropdown updates the `defaultCurrency` used by `parseMoney()`.\n    *   Verify that the parsing results on the demo website reflect the selected `defaultCurrency` when no currency is detected in the input text.\n    *   Test with various input strings and different default currencies to ensure the functionality works as expected.\n3.  **End-to-End Tests:**\n    *   Create end-to-end tests that simulate user interactions on the demo website, including selecting a default currency and entering monetary expressions. Verify that the parsing results are correct.",
        "status": "done",
        "dependencies": [
          5,
          6,
          20,
          32,
          37
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ParseOptions Interface",
            "description": "Define the `ParseOptions` interface with an optional `defaultCurrency` field (string, ISO-4217 code).",
            "dependencies": [],
            "details": "Create a new file `src/types/ParseOptions.ts` (or add to an existing types file) and define the `ParseOptions` interface. The `defaultCurrency` field should be optional and of type string. Set the default value to 'USD' in the `parseMoney` function if the option is not provided.",
            "status": "done",
            "testStrategy": "N/A - Type definition only."
          },
          {
            "id": 2,
            "title": "Update parseMoney() Function Signature",
            "description": "Modify the `parseMoney()` function signature to accept an optional `options` parameter of type `ParseOptions`.",
            "dependencies": [],
            "details": "Update the `parseMoney()` function signature in `src/parseMoney.ts` to accept an optional `options` parameter of type `ParseOptions`. Ensure backwards compatibility by providing a default value for the options parameter if it's not provided.",
            "status": "done",
            "testStrategy": "Create a unit test to ensure that `parseMoney` still works correctly when no options are passed."
          },
          {
            "id": 3,
            "title": "Update RegexPipeline to Propagate defaultCurrency",
            "description": "Update the RegexPipeline to accept and propagate the `defaultCurrency` option through the PipelineContext.",
            "dependencies": [],
            "details": "Modify the `RegexPipeline.run()` method to accept the `defaultCurrency` from the `ParseOptions` and pass it down to the `PipelineContext`. This will make the `defaultCurrency` available to the currency detection step.",
            "status": "done",
            "testStrategy": "Add a unit test to verify that the `defaultCurrency` is correctly passed to the `PipelineContext`."
          },
          {
            "id": 4,
            "title": "Modify Currency Detection to Apply Default Currency",
            "description": "Modify the currency detection step in the RegexPipeline to apply the `defaultCurrency` as a fallback when no currency is detected in the input text.",
            "dependencies": [],
            "details": "Within the currency detection logic in the RegexPipeline, check if a currency has been detected. If not, use the `defaultCurrency` from the `PipelineContext` to create a `Currency` object. Ensure that the original detected value is null if the default currency is applied.",
            "status": "done",
            "testStrategy": "Create unit tests to verify that the `defaultCurrency` is correctly applied when no currency is detected in the input text. Also, test cases where a currency is detected, ensuring the detected currency takes precedence."
          },
          {
            "id": 5,
            "title": "Add Validation for defaultCurrency",
            "description": "Validate the `defaultCurrency` code against the `currency-codes` package to ensure it's a valid ISO-4217 currency code. Throw a `MoneyParseError` if the code is invalid.",
            "dependencies": [],
            "details": "Use the `currency-codes` package to validate the `defaultCurrency` code within the `parseMoney()` function. If the code is invalid, throw a `MoneyParseError` with a descriptive message. Ensure the validation happens before the RegexPipeline is executed.",
            "status": "done",
            "testStrategy": "Create unit tests to verify that a `MoneyParseError` is thrown when an invalid currency code is provided as the `defaultCurrency`. Also, test with valid currency codes to ensure no error is thrown."
          },
          {
            "id": 6,
            "title": "Update README Documentation",
            "description": "Add examples to the README demonstrating how to use the `defaultCurrency` option.",
            "dependencies": [],
            "details": "Update the `README.md` file with clear examples of how to use the `defaultCurrency` option in the `parseMoney()` function. Include examples with valid and invalid currency codes. Also, add JSDoc comments to new interfaces and updated functions.",
            "status": "done",
            "testStrategy": "Manually review the README to ensure the examples are clear and accurate."
          },
          {
            "id": 7,
            "title": "Add Currency Dropdown to Demo Website",
            "description": "Add a currency dropdown selector to the demo website (`demo/src/App.jsx`) allowing users to select a default currency.",
            "dependencies": [],
            "details": "Modify the `demo/src/App.jsx` file to include a currency dropdown selector. Populate the dropdown with common currencies (USD, EUR, GBP, JPY, etc.). Store the selected currency in the component's state.",
            "status": "done",
            "testStrategy": "Manually test the demo website to ensure the dropdown is displayed correctly and populated with the correct currencies."
          },
          {
            "id": 8,
            "title": "Wire Up Dropdown to Pass defaultCurrency to parseMoney and Show Visual Indication",
            "description": "Wire up the currency dropdown to pass the selected `defaultCurrency` option to the `parseMoney()` function and show a visual indication when the default currency is being applied vs detected currency.",
            "dependencies": [],
            "details": "Update the `demo/src/App.jsx` file to pass the selected currency from the dropdown to the `parseMoney()` function as the `defaultCurrency` option. Add logic to display a visual indication (e.g., a message or different styling) when the `defaultCurrency` is being applied instead of a detected currency. The visual indication should clearly communicate whether the parsed currency was detected or defaulted.",
            "status": "done",
            "testStrategy": "Manually test the demo website to ensure the selected currency is correctly passed to `parseMoney()` and that the visual indication is displayed correctly when the `defaultCurrency` is being applied."
          }
        ]
      },
      {
        "id": 39,
        "title": "Fix Decimal Numbers Before Magnitude Words",
        "description": "Fix the issue where decimal numbers followed by magnitude words (e.g., '2.25 thousand') are not correctly parsed, resulting in incorrect numeric values. This task involves modifying the `parseAmountTokens` function in `contextualPhrases.ts` to properly handle this scenario.",
        "details": "Modify the regex check within the `parseAmountTokens` function in `contextualPhrases.ts` to correctly identify and process decimal numbers followed by magnitude words. The current regex prematurely matches the full string, causing an early return with an incorrect value. The updated regex should specifically target the numeric part and the magnitude word, allowing for accurate calculation. Ensure that the fix handles various magnitude words (thousand, million, billion, etc.) and different decimal formats. Consider adding a new unit test file to isolate these tests from the other unit tests.",
        "testStrategy": "Create new unit tests specifically for decimal numbers followed by magnitude words. These tests should cover a range of values and magnitude words, including '2.25 thousand', '1.5 million', '0.75 billion', etc. Verify that the parsed values are accurate (e.g., '2.25 thousand' should return 2250). Also, test edge cases such as very small decimal numbers (e.g., '0.001 million') and very large numbers (e.g., '999.999 million'). Ensure that the existing unit tests are not negatively impacted by this change. Run all unit tests to confirm the fix does not introduce regressions.",
        "status": "done",
        "dependencies": [
          7,
          9,
          10,
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Integrate Regional Format Parser into Main Pipeline",
        "description": "Integrate the existing regional format parser into the main regex pipeline to correctly handle European decimal separators and other regional number formats. This includes adding the parser to the pipeline, handling ambiguity, and adding comprehensive tests.",
        "details": "1.  **Add regionalFormatDetectionStep to pipeline:** Modify the `regexPipeline` to include the `regionalFormatDetectionStep` before the `plainNumericDetection` step. This ensures that regional formats are parsed before attempting to parse numbers with US-style formatting.\n2.  **Handle ambiguity detection for \"1.000\":** Implement logic to differentiate between European \"1.000\" (one thousand) and US \"1.0\" (one point zero). This may involve checking for surrounding currency symbols or other contextual clues. Consider adding a configuration option to specify the default locale if ambiguity cannot be resolved.\n3.  **Update regexPipeline:** Ensure the regional format parser is correctly instantiated and configured within the `regexPipeline`.\n4.  **Error Handling:** Implement robust error handling to gracefully manage cases where regional format parsing fails or produces unexpected results. Log errors appropriately for debugging purposes.\n5.  **Performance Considerations:** Evaluate the performance impact of adding the regional format parser to the pipeline. Optimize the parser's implementation to minimize any performance overhead.",
        "testStrategy": "1.  **Comprehensive tests for European format:** Create a suite of unit tests specifically designed to test the regional format parser with European number formats. These tests should include:\n    *   Numbers with period as thousands separator: \"1.000.000\", \"10.000\"\n    *   Numbers with comma as decimal separator: \"1,234\", \"123,45\"\n    *   Numbers with currency symbols: \"1.234,56 EUR\", \"1.000.000,00 $\"\n    *   Numbers with mixed formats (if applicable).\n2.  **Ambiguity tests:** Create tests to specifically address the ambiguity of numbers like \"1.000\". These tests should include cases where the context suggests a European format and cases where it suggests a US format.\n3.  **Regression tests:** Run existing tests to ensure that the integration of the regional format parser does not negatively impact the parsing of other number formats.\n4.  **Edge case tests:** Include tests for edge cases such as invalid or malformed input strings.\n5.  **Performance tests:** Measure the execution time of the pipeline with and without the regional format parser to identify any performance regressions.",
        "status": "done",
        "dependencies": [
          19,
          10,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Negative Number Support",
        "description": "Add functionality to correctly identify and handle negative numbers in currency strings, including negative prefixes, parentheses notation, and updating the pipeline context.",
        "details": "1. **Create negative detection utilities:** Implement functions to detect negative prefixes such as \"-\", \"minus\", and \"negative\" before the currency amount. Also, implement logic to detect parentheses notation, where (100) implies -100.\n2. **Add negativeDetectionStep to pipeline:** Integrate a new step early in the parsing pipeline to utilize the negative detection utilities. This step should identify and flag negative amounts before other parsers are applied.\n3. **Store negative flag in PipelineContext:** Modify the PipelineContext to include an `isNegative` boolean flag. The `negativeDetectionStep` should set this flag accordingly.\n4. **Apply negative flag to final amount:** At the end of the pipeline, apply the `isNegative` flag to the final extracted amount. If the flag is true, multiply the amount by -1.\n5. **Handle parentheses notation:** Implement logic to detect and handle parentheses notation, where (100) implies -100. This should be integrated into the negative detection utilities.\n6. **Update type definitions:** Update relevant type definitions (e.g., interfaces for PipelineContext, parser outputs) to include the `isNegative` flag.\n7. **Consider interactions with existing parsers:** Ensure the negative number handling logic interacts correctly with all existing parsers (e.g., Symbols, Abbreviations, Regional Formats). Pay special attention to the order of operations to avoid conflicts.\n8. **Group Assignment:** This task belongs to Group C.",
        "testStrategy": "1. **Unit tests for negative detection utilities:** Create unit tests to verify the correct detection of negative prefixes (\"-\", \"minus\", \"negative\") and parentheses notation.\n2. **Integration tests for the pipeline:** Write integration tests to verify the entire pipeline correctly handles negative numbers in various formats, including:\n    *   Negative prefixes: \"-100 EUR\", \"minus 50 USD\", \"negative 25 GBP\"\n    *   Parentheses notation: \"(100) USD\", \"(50.50) EUR\"\n    *   Combinations with existing patterns: \"-$100\", \"(EUR 50)\", \"-1,234.56 USD\"\n3. **Comprehensive testing with all existing patterns:** Combine negative number patterns with all existing patterns (Symbols, Abbreviations, Regional Formats, Worded Numbers, etc.) to ensure no regressions are introduced. This includes positive and negative cases.\n4. **Edge cases:** Test edge cases such as multiple negative prefixes (e.g., \"--100 EUR\") and invalid parentheses (e.g., \"(100 EUR\").\n5. **Test the isNegative flag:** Verify that the `isNegative` flag in the PipelineContext is correctly set and applied to the final amount.",
        "status": "done",
        "dependencies": [
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Extend Fractional Parser to Support Magnitude Words",
        "description": "Extend the fractional parser to correctly handle magnitude words (e.g., 'million', 'billion') following fractions, addressing the issue where 'a quarter million' currently returns 0.25 instead of 250000. This task involves modifying the parser and adding comprehensive tests.",
        "details": "1) Extend `parseFractionalWordedNumber` to handle optional magnitude words after fractions. This will likely involve adding a new regular expression or conditional logic to detect and parse magnitude words.\n2) Implement parsing logic for the pattern: fraction + magnitude (e.g., 'quarter million', 'half billion'). Ensure correct multiplication of the fractional value with the magnitude value.\n3) Implement parsing logic for the pattern: fraction + 'of a' + magnitude (e.g., 'quarter of a million'). Handle the 'of a' phrase correctly to extract the magnitude.\n4) Integrate the updated parser into `contextualPhrases` to support this pattern in contextual parsing scenarios. This may require modifications to the contextual parsing logic to recognize and utilize the new fractional magnitude pattern.\n5) Update documentation to reflect the changes made to the fractional parser and the new supported patterns.",
        "testStrategy": "1) Create unit tests for all fractional magnitude combinations, including 'quarter million', 'half billion', 'third trillion', etc. Verify that the parser returns the correct numeric value for each combination.\n2) Create unit tests for the 'fraction + of a + magnitude' pattern, such as 'quarter of a million', 'half of a billion', etc. Verify correct parsing and numeric conversion.\n3) Add tests to `contextualPhrases` to ensure the new pattern is correctly parsed in contextual scenarios. Test with various surrounding words and phrases to ensure accurate results.\n4) Test with different fractional values (e.g., 'one fifth', 'three quarters') combined with different magnitudes (e.g., 'thousand', 'million', 'billion').\n5) Include edge cases and boundary conditions in the tests, such as very large magnitudes or unusual fractional values.",
        "status": "done",
        "dependencies": [
          7,
          9,
          15,
          16
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Enhance Minor Unit Handling in Contextual Phrases",
        "description": "Update the contextualPhrases regex to optionally include 'and' between major and minor currency units, and add validation to ensure correct minor unit parsing.",
        "details": "1. Modify the contextualPhrases regular expression to make the 'and' connector optional between major and minor currency units (e.g., allow both '5 pounds and 20 pence' and '5 pounds 20 pence').\n2. Implement validation to confirm that the trailing number after the major unit is a valid minor unit (e.g., less than 100 for cents, pence, etc.).\n3. Ensure compatibility with colloquial patterns like 'a dollar fifty' and extend support to patterns like '5 pounds 20'.\n4. Add comprehensive unit tests covering all major+minor currency combinations, both with and without the 'and' connector (e.g., '5 pounds 20 pence', '2 euros 50', 'ten dollars 25', '5 pounds and 20 pence').\n5. Implement validation to ensure the minor amount is valid (e.g., less than 100 for cents/pence).\n6. Update relevant documentation to reflect the support for both formats (with and without 'and').",
        "testStrategy": "1. Create unit tests for various currency combinations with and without the 'and' connector (e.g., '5 pounds 20 pence', '2 euros 50', 'ten dollars 25', '5 pounds and 20 pence', '10 dollars and 99 cents').\n2. Verify that the parser correctly extracts the major and minor units in all test cases.\n3. Implement negative test cases with invalid minor unit amounts (e.g., '5 pounds 150 pence') and ensure they are correctly rejected.\n4. Test with different currencies to ensure the validation logic is currency-specific (e.g., validate against 100 for cents/pence, but adjust for other currencies with different minor unit ranges if applicable).\n5. Verify that the updated documentation accurately reflects the supported formats.",
        "status": "done",
        "dependencies": [
          12,
          13,
          19,
          20
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Add RangeParseResult Interface to types.ts",
        "description": "Define a new TypeScript interface, RangeParseResult, in types.ts to represent the structure of range parsing results, including min, max, currency, and raw input fields. This interface will be used to represent the output of monetary range parsing.",
        "details": "1.  Open the `types.ts` file.\n2.  Define the `RangeParseResult` interface with the following properties:\n    *   `min`: `number | null` - The minimum value of the range, or null if not applicable.\n    *   `max`: `number | null` - The maximum value of the range, or null if not applicable.\n    *   `currency`: `string | null` - The ISO currency code, or null if not detected.\n    *   `raw`: `string` - The original input string that was parsed.\n3.  Ensure the interface is properly exported for use in other modules.\n\nExample:\n\n```typescript\nexport interface RangeParseResult {\n  min: number | null;\n  max: number | null;\n  currency: string | null;\n  raw: string;\n}\n```",
        "testStrategy": "1.  Verify that the `RangeParseResult` interface is correctly defined in `types.ts` with the specified properties and types.\n2.  Create a separate test file (e.g., `range-parse-result.test.ts`) to import and use the `RangeParseResult` interface.\n3.  Instantiate a `RangeParseResult` object with sample data and assert that the properties are correctly assigned and accessible.\n4.  Check that the interface is properly exported and can be imported into other modules without errors.\n5.  Run the TypeScript compiler to ensure there are no type errors related to the new interface.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Implement Monetary Range Parser Module",
        "description": "Create a new module for parsing monetary ranges, including helper functions and basic parsing logic.",
        "details": "1.  **Create `src/patterns/ranges.ts`:** Create a new file `src/patterns/ranges.ts`.\n2.  **Implement `normalizeInput` Helper:** Implement a `normalizeInput(input: string): string` function to normalize the input string by trimming whitespace and converting to lowercase.\n3.  **Define `rangeSeparatorRegex`:** Define a regular expression `rangeSeparatorRegex: RegExp` that matches common range separators (e.g., '-', '–', '—', 'to', 'through'). Ensure the regex is case-insensitive.\n4.  **Implement `parseRange` Function Stub:** Implement a `parseRange(input: string): RangeParseResult | null` function stub. This function should:\n    *   Use `normalizeInput` to preprocess the input.\n    *   Use `rangeSeparatorRegex` to split the input into two potential values.\n    *   Return a `RangeParseResult` object (defined in task 44) with `min` and `max` set to `null` initially. The `currency` should also be `null` and the `raw` field should contain the original input string.\n    *   Return `null` if the input is not a valid range.\n5.  **Implement `matchRange` Function Stub:** Implement a `matchRange(input: string): boolean` function stub. This function should:\n    *   Use `normalizeInput` to preprocess the input.\n    *   Use `rangeSeparatorRegex` to test if the input string contains a range separator.\n    *   Return `true` if a range separator is found, `false` otherwise.\n6.  **Export Functions and Regex:** Export `normalizeInput`, `rangeSeparatorRegex`, `parseRange`, and `matchRange` from the module.",
        "testStrategy": "1.  **Unit Tests for `normalizeInput`:**\n    *   Test with various input strings containing leading/trailing whitespace.\n    *   Test with mixed-case input strings.\n    *   Verify that the output is correctly trimmed and lowercased.\n2.  **Unit Tests for `rangeSeparatorRegex`:**\n    *   Test with different range separators ('-', '–', '—', 'to', 'through') in various positions within a string.\n    *   Verify that the regex correctly identifies the separators.\n    *   Verify that the regex is case-insensitive.\n3.  **Unit Tests for `matchRange`:**\n    *   Test with strings containing valid range separators.\n    *   Test with strings not containing range separators.\n    *   Test with empty strings.\n    *   Verify that the function returns the correct boolean value in each case.\n4.  **Unit Tests for `parseRange`:**\n    *   Test with strings containing valid range separators.\n    *   Test with strings not containing range separators.\n    *   Test with empty strings.\n    *   Verify that the function returns a `RangeParseResult` object with `null` values for `min` and `max` and the correct `raw` value when a valid range is detected.\n    *   Verify that the function returns `null` when an invalid range is detected.",
        "status": "pending",
        "dependencies": [
          44
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Implement parseSingleValue helper function in ranges.ts",
        "description": "Implement a helper function that can parse a single monetary value from any supported format, reusing existing pattern parsers internally. This function should return an object containing the parsed value and currency.",
        "details": "1.  **Create `parseSingleValue` Function:** Implement a function `parseSingleValue(input: string): { value: number; currency?: string } | null` in `src/patterns/ranges.ts`. This function will be the main entry point for parsing single monetary values.\n2.  **Normalize Input:** Use the `normalizeInput` helper function (Task 45) to normalize the input string.\n3.  **Iterate Through Parsers:** Iterate through the existing pattern parsers (Plain Numbers, Symbols, Abbreviations, Worded Numbers, Fractional Worded Numbers, Numeric-Word Combos, Slang Terms, Regional Formats).\n4.  **Apply Parsers:** Apply each parser to the normalized input string.\n5.  **Handle Parser Results:**\n    *   If a parser successfully parses the input, extract the numeric value and currency (if any).\n    *   If multiple parsers return a result, prioritize based on parser specificity (e.g., Regional Formats > Plain Numbers).\n6.  **Currency Normalization:** Use the currency normalization logic (Task 20) to normalize any detected currency to its ISO 4217 code.\n7.  **Return Result:** Return an object `{ value: number; currency?: string }` containing the parsed value and normalized currency (if detected). If no parser successfully parses the input, return `null`.",
        "testStrategy": "1.  **Unit Tests for `parseSingleValue`:**\n    *   Test with various input strings covering all supported formats (plain numbers, numbers with separators, magnitude suffixes, worded numbers, slang terms, regional formats).\n    *   Test with strings containing currency symbols, abbreviations, and names.\n    *   Test with strings that should not be parsed (e.g., invalid formats, non-monetary strings).\n    *   Verify that the function correctly extracts the numeric value and currency for each input string.\n    *   Verify that the function correctly normalizes the currency to its ISO 4217 code.\n    *   Verify that the function returns `null` for invalid input strings.\n2.  **Specific Test Cases:**\n    *   `'123'` -> `{ value: 123 }`\n    *   `'$100'` -> `{ value: 100, currency: 'USD' }`\n    *   `'USD 50'` -> `{ value: 50, currency: 'USD' }`\n    *   `'one hundred dollars'` -> `{ value: 100, currency: 'USD' }`\n    *   `'half a dollar'` -> `{ value: 0.5, currency: 'USD' }`\n    *   `'10k'` -> `{ value: 10000 }`\n    *   `'buck'` -> `{ value: 1, currency: 'USD' }`\n    *   `'1.234,56 €'` -> `{ value: 1234.56, currency: 'EUR' }`\n    *   `'invalid input'` -> `null`",
        "status": "pending",
        "dependencies": [
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          45
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement symbol-based range parsing in ranges.ts",
        "description": "Add support for parsing ranges with currency symbols like \"$500 - $1000\", \"$500-$1000\", \"$500 to $1000\", \"€50 - €100\", \"$500 - 1000\" (symbol on first value only) in ranges.ts. Reuse existing symbol parsing logic.",
        "details": "1.  **Locate `ranges.ts`:** Open the `src/patterns/ranges.ts` file.\n2.  **Implement Symbol-Based Range Parsing:** Modify the range parsing logic to handle currency symbols at the beginning of the range. This will likely involve:\n    *   Checking for a currency symbol at the start of each value in the range.\n    *   Using the `parseSingleValue` helper function (Task 46) to parse each value, extracting the currency and numeric amount.\n    *   Handling cases where the currency symbol is only present on the first value in the range (e.g., \"$500 - 1000\"). In such cases, apply the currency from the first value to the second value if no currency symbol is present on the second value.\n    *   Ensure that the parsing logic correctly handles different range separators (e.g., \"-\", \"to\", etc.) as defined in `rangeSeparatorRegex`.\n3.  **Reuse `parseSingleValue`:** Utilize the `parseSingleValue` helper function (Task 46) to parse the individual values within the range. This ensures consistency with existing parsing logic for single monetary values.\n4.  **Reuse Symbol Parsing:** Leverage the existing symbol parsing logic from `patterns/symbols.ts` (Task 12) to identify and extract currency symbols.\n5.  **Handle Edge Cases:** Consider edge cases such as:\n    *   Invalid currency symbols.\n    *   Missing values in the range.\n    *   Ranges with more than two values (should be treated as invalid).\n    *   Conflicting currency symbols (e.g., \"$500 - €1000\").\n6.  **Return `RangeParseResult`:** Ensure the parsing logic returns a `RangeParseResult` object (Task 44) with the correct `min`, `max`, and `currency` values.\n7.  **Error Handling:** Implement appropriate error handling to gracefully handle invalid input and prevent the parser from crashing.\n8.  **Code Comments:** Add clear and concise code comments to explain the parsing logic and the handling of different cases.",
        "testStrategy": "1.  **Unit Tests for Symbol-Based Ranges:**\n    *   Write unit tests to cover the following cases:\n        *   Ranges with currency symbols on both values (e.g., \"$500 - $1000\", \"€50 - €100\").\n        *   Ranges with a currency symbol only on the first value (e.g., \"$500 - 1000\").\n        *   Ranges with different range separators (e.g., \"$500 to $1000\", \"$500-$1000\").\n        *   Ranges with invalid currency symbols (should return null or an error).\n        *   Ranges with missing values (should return null or an error).\n        *   Ranges with conflicting currency symbols (e.g., \"$500 - €1000\") - define expected behavior (error or take first currency).\n        *   Ranges with whitespace variations (e.g., \" $500 - $1000 \").\n    *   Verify that the `min`, `max`, and `currency` values in the `RangeParseResult` object are correctly populated.\n    *   Verify that the tests cover different currency symbols ($, €, £, etc.).\n2.  **Integration Tests:**\n    *   Write integration tests to ensure that the symbol-based range parsing logic integrates correctly with the `parseMoney` and `parseAll` functions (Tasks 21 and 22).\n    *   Test with input strings containing multiple monetary expressions, including symbol-based ranges.\n3.  **Regression Tests:**\n    *   Run existing unit tests to ensure that the changes do not introduce any regressions in the existing parsing logic.",
        "status": "pending",
        "dependencies": [
          12,
          44,
          45,
          46
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Implement ISO code range parsing in ranges.ts",
        "description": "Add support for parsing ranges with ISO currency codes like \"100 - 200 USD\", handling both prefix and suffix ISO code positions. This task extends the range parsing functionality to recognize currency codes within monetary ranges.",
        "details": "1.  **Extend `parseSingleValue` Function:** Modify the `parseSingleValue` function in `src/patterns/ranges.ts` to detect and handle ISO currency codes within the input string.\n2.  **Currency Code Detection:** Implement logic to identify currency codes (e.g., \"USD\", \"EUR\") either before or after the numeric values in the range. Leverage existing currency normalization logic (Task 20) to ensure consistent handling of currency codes.\n3.  **Range Parsing Logic:** Update the range parsing logic to correctly extract the currency code and associate it with the parsed values. Ensure that the currency code is consistently applied to both the minimum and maximum values of the range.\n4.  **Handle Prefix and Suffix Positions:** Implement parsing logic that correctly identifies and extracts currency codes regardless of whether they appear before or after the numeric values (e.g., \"USD 100 - 200\" vs. \"100 - 200 USD\").\n5.  **Update `RangeParseResult`:** Ensure the `RangeParseResult` interface is correctly populated with the parsed currency code.\n6.  **Error Handling:** Implement error handling for cases where the currency code is invalid or cannot be normalized.",
        "testStrategy": "1.  **Unit Tests for ISO Code Parsing:**\n    *   Test with various input strings containing ISO currency codes in both prefix and suffix positions (e.g., \"100 - 200 USD\", \"USD 100 - 200\", \"100-200 EUR\", \"EUR 100 to 200\").\n    *   Test with different range separators (e.g., \"-\", \"to\", \"through\").\n    *   Test with various currency codes (e.g., \"USD\", \"EUR\", \"GBP\", \"CAD\").\n    *   Test with invalid currency codes to ensure proper error handling.\n    *   Test with ranges where only one value has a currency code (should default to null or throw an error based on configuration).\n2.  **Integration Tests:**\n    *   Integrate the ISO code parsing logic into the existing range parsing tests to ensure compatibility and correct behavior.\n3.  **Verify `RangeParseResult`:**\n    *   Verify that the `RangeParseResult` object is correctly populated with the parsed currency code, minimum value, and maximum value.",
        "status": "pending",
        "dependencies": [
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          45,
          46
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement Magnitude Suffix Range Parsing",
        "description": "Add support for parsing monetary ranges with magnitude suffixes (k, m, b) in ranges.ts, handling mixed magnitudes and currency symbols.",
        "details": "1.  **Modify `parseSingleValue` Function:** Update the `parseSingleValue` function in `src/patterns/ranges.ts` to correctly parse monetary values with magnitude suffixes (k, m, b). This will involve checking for and extracting the suffix, then multiplying the numeric value accordingly.\n2.  **Handle Mixed Magnitudes:** Ensure the parsing logic can handle ranges with mixed magnitudes (e.g., \"200k - 1M\"). This might require parsing each value in the range separately and then comparing/combining them.\n3.  **Currency Symbol Handling:** Extend the parsing logic to correctly handle currency symbols within the range string (e.g., \"$10k - $20k\", \"10k - 20k USD\"). Ensure the currency is consistently extracted and applied to both the minimum and maximum values.\n4.  **Update Range Parsing Logic:** Modify the range parsing logic to utilize the updated `parseSingleValue` function to parse the individual values within the range.\n5.  **Error Handling:** Implement error handling to gracefully handle invalid magnitude suffixes or malformed range strings.\n6.  **Considerations:**\n    *   Ensure that the magnitude suffixes are case-insensitive (e.g., 'k' and 'K' should both be recognized).\n    *   Handle potential whitespace variations around the magnitude suffixes and currency symbols.\n    *   Consider the impact on performance and optimize the parsing logic if necessary.",
        "testStrategy": "1.  **Unit Tests for `parseSingleValue`:**\n    *   Test with various input strings containing magnitude suffixes (e.g., \"10k\", \"200k\", \"1M\", \"2M\", \"1b\", \"10B\").\n    *   Test with mixed magnitudes (e.g., \"200k\", \"1M\").\n    *   Test with currency symbols (e.g., \"$10k\", \"10k USD\", \"€2M\").\n    *   Test with whitespace variations (e.g., \"10 k\", \"$ 10k\", \"10k USD\").\n    *   Test with invalid magnitude suffixes (e.g., \"10x\", \"200z\").\n2.  **Integration Tests for Range Parsing:**\n    *   Test with various range strings containing magnitude suffixes (e.g., \"10k - 20k\", \"200k - 1M\", \"1M - 2M\", \"$10k - $20k\", \"10k - 20k USD\").\n    *   Test with mixed magnitudes (e.g., \"200k - 1M\").\n    *   Test with different currency symbols and placements.\n    *   Test with invalid range strings (e.g., missing separator, invalid magnitude suffixes).\n3.  **Verify Correct Value Extraction:**\n    *   Ensure that the parsed minimum and maximum values are correctly extracted and converted to numeric values.\n    *   Verify that the currency is correctly identified and associated with the range.\n4.  **Error Handling Verification:**\n    *   Ensure that appropriate errors are thrown or handled for invalid input strings.",
        "status": "pending",
        "dependencies": [
          46,
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          45
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement Slang Term Range Parsing in ranges.ts",
        "description": "Add support for parsing ranges with slang terms like \"500 to 1000 bucks\", \"50 - 100 quid\", \"five to ten bucks\" in ranges.ts. Integrate with existing slangTerms.ts parser.",
        "details": "1.  **Update `parseSingleValue` Function:** Modify the `parseSingleValue(input: string)` function in `src/patterns/ranges.ts` to correctly handle slang terms within range expressions.\n2.  **Slang Term Integration:** Ensure that the existing slang term parser (`src/patterns/slangTerms.ts` and Task 17) is utilized within `parseSingleValue` to identify and extract slang terms.\n3.  **Range Parsing Logic:** Adapt the range parsing logic to accommodate slang terms. This includes correctly identifying the currency associated with the slang term and extracting the numeric values.\n4.  **Handle Mixed Units:** Consider cases where slang terms might be mixed with standard currency symbols or abbreviations (e.g., \"50 USD to 100 bucks\"). Implement logic to handle such scenarios, potentially prioritizing explicit currency symbols or abbreviations.\n5.  **Update `rangeSeparatorRegex` (if needed):** Review the `rangeSeparatorRegex` in `src/patterns/ranges.ts` (defined in Task 45) and update it if necessary to correctly handle range separators used with slang terms.\n6.  **Error Handling:** Implement appropriate error handling for cases where slang terms cannot be parsed or are used in invalid range expressions.\n7.  **Return Values:** Ensure that the `parseSingleValue` function returns the correct value and currency information when slang terms are successfully parsed within a range.",
        "testStrategy": "1.  **Unit Tests for `parseSingleValue` with Slang Terms:**\n    *   Test with various input strings containing slang terms in range expressions (e.g., \"500 to 1000 bucks\", \"50 - 100 quid\", \"five to ten bucks\").\n    *   Test with different range separators (e.g., \"to\", \"-\", \"–\") used with slang terms.\n    *   Test with mixed units (e.g., \"50 USD to 100 bucks\", \"10 EUR - 20 quid\").\n    *   Test with invalid or unparseable slang term expressions.\n    *   Verify that the correct numeric values and currency information are extracted and returned.\n2.  **Integration Tests:**\n    *   Create integration tests that combine slang term range parsing with other range parsing scenarios to ensure compatibility and correct behavior.\n3.  **Edge Cases:**\n    *   Test with edge cases such as very large or very small numbers combined with slang terms.\n    *   Test with different regional variations in slang term usage (if applicable).",
        "status": "pending",
        "dependencies": [
          17,
          45,
          46
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Implement Worded Number Range Parsing in ranges.ts",
        "description": "Add support for parsing ranges with worded numbers like 'five to ten dollars' in ranges.ts, integrating with the existing wordedNumbers.ts parser and parseSingleValue function.",
        "details": "1.  **Update `src/patterns/ranges.ts`:** Modify the `parseRange` function (or create it if it doesn't exist) in `src/patterns/ranges.ts` to handle worded number ranges.\n2.  **Leverage `parseSingleValue`:** Use the `parseSingleValue` function (Task 46) to parse the individual values within the range string.\n3.  **Worded Number Detection:** Enhance the range parsing logic to detect range separators (e.g., 'to', 'through') between worded numbers. Ensure the `rangeSeparatorRegex` (Task 45) is used effectively.\n4.  **Integration with `wordedNumbers.ts`:** Ensure that the existing worded number parsing logic (Task 14) is correctly utilized via `parseSingleValue` when encountering worded numbers in the range string.\n5.  **Currency Handling:** Handle currency symbols or abbreviations that may appear before, after, or within the worded number range (e.g., 'five to ten dollars', 'USD five to ten').\n6.  **Error Handling:** Implement error handling to gracefully manage cases where the input string is not a valid worded number range.\n7.  **Update `RangeParseResult`:** Ensure the parsed values are correctly assigned to the `min` and `max` properties of the `RangeParseResult` interface (Task 44).\n8.  **Consider edge cases:** Handle cases where only one value is provided (e.g., \"up to five dollars\") or where the range is open-ended.\n9.  **Normalization:** Ensure input normalization (Task 45) is applied before parsing to handle variations in spacing and casing.",
        "testStrategy": "1.  **Unit Tests for Worded Number Ranges:**\n    *   Test with various worded number ranges, including different currencies and range separators (e.g., 'five to ten dollars', 'one hundred to two hundred euros', 'fifty - one hundred pounds').\n    *   Test with ranges where the currency is specified before, after, or within the numbers (e.g., 'USD five to ten', 'five to ten USD').\n    *   Test with single-value ranges (e.g., 'up to five dollars').\n    *   Test with invalid inputs to ensure proper error handling.\n2.  **Integration Tests:**\n    *   Create integration tests that combine worded number ranges with other types of monetary expressions to ensure compatibility.\n3.  **Edge Case Testing:**\n    *   Test with unusual or ambiguous inputs to verify the parser's robustness.\n4.  **Verify `RangeParseResult`:**\n    *   Ensure that the `min`, `max`, and `currency` properties of the `RangeParseResult` object are correctly populated for all test cases.",
        "status": "pending",
        "dependencies": [
          14,
          44,
          45,
          46
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement Contextual Phrase Range Parsing in ranges.ts",
        "description": "Add support for parsing contextual range phrases like \"between $100 and $200\" and \"from $50 to $100\" in the ranges.ts module. This involves creating new parsing logic to identify and extract monetary values from these specific phrase patterns.",
        "details": "1.  **Update `src/patterns/ranges.ts`:** Modify the `ranges.ts` file to include the new parsing logic.\n2.  **Implement `parseContextualRange` Function:** Create a function `parseContextualRange(input: string): RangeParseResult | null` within `ranges.ts`. This function will handle the parsing of contextual range phrases.\n3.  **Define Regex Patterns:** Define regular expression patterns to match the \"between X and Y\" and \"from X to Y\" patterns, ensuring they are case-insensitive and can handle various currency symbols/codes and number formats.\n4.  **Use `parseSingleValue`:** Utilize the `parseSingleValue` helper function (Task 46) to extract the individual monetary values (X and Y) from the matched phrases.\n5.  **Handle Currency Consistency:** Ensure that both values (X and Y) have the same currency. If currencies differ or are not present, handle the scenario appropriately (e.g., return null or a specific error).\n6.  **Create RangeParseResult:** Construct and return a `RangeParseResult` object (defined in Task 44) containing the min, max, and currency values. Ensure `min` and `max` are correctly assigned based on the parsed values.\n7.  **Integrate with Main Parsing Logic:** Integrate the `parseContextualRange` function into the main parsing logic within `ranges.ts`, ensuring it's called appropriately when contextual range phrases are detected.\n8.  **Error Handling:** Implement robust error handling to manage cases where the input string does not match the expected patterns or contains invalid monetary values.",
        "testStrategy": "1.  **Unit Tests for `parseContextualRange`:**\n    *   Test with various input strings containing \"between X and Y\" and \"from X to Y\" phrases, covering different currency symbols/codes, number formats, and whitespace variations.\n    *   Test with strings where X and Y are in different currencies or one/both are missing currency information. Verify that the function returns `null` or handles the error appropriately.\n    *   Test with strings where X is greater than Y and vice versa to ensure `min` and `max` are correctly assigned in the `RangeParseResult`.\n    *   Test with invalid input strings that do not match the expected patterns. Verify that the function returns `null`.\n2.  **Integration Tests:**\n    *   Create integration tests that combine contextual range phrases with other types of monetary expressions to ensure the parsing logic works correctly in complex scenarios.\n3.  **Edge Cases:**\n    *   Test with very large or very small numbers to ensure the parsing logic handles them correctly.\n    *   Test with strings containing special characters or potentially malicious input to ensure the parsing logic is robust and secure.",
        "status": "pending",
        "dependencies": [
          44,
          45,
          46
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement Mixed Format Range Parsing in ranges.ts",
        "description": "Add support for parsing ranges with mixed formats like \"10k - 1M\" (different magnitudes), \"ten to 100 dollars\" (worded + numeric), \"$50 - 100\" (symbol on one side) in ranges.ts. The `parseSingleValue` helper should handle each side independently.",
        "details": "1. **Modify `parseSingleValue` Function:** Update the `parseSingleValue` function in `src/patterns/ranges.ts` to handle mixed formats within range expressions. This will involve checking for and correctly parsing different magnitude suffixes, worded and numeric combinations, and currency symbols on either side of the range.\n2. **Handle Mixed Magnitudes:** Ensure the parsing logic can handle ranges with mixed magnitudes (e.g., \"200k - 1M\"). This might require parsing each value in the range separately and then comparing/combining the results.\n3. **Handle Worded and Numeric Combinations:** Implement logic to handle ranges that combine worded numbers and numeric values (e.g., \"ten to 100 dollars\"). This will require correctly parsing the worded number and converting it to its numeric equivalent.\n4. **Handle Currency Symbols on One Side:** Adapt the parsing logic to accommodate currency symbols appearing only on one side of the range (e.g., \"$50 - 100\"). The currency should be applied to both values in the range.\n5. **Reuse Existing Parsers:** Ensure that the existing pattern parsers (Plain Numbers, Symbols, Abbreviations, Worded Numbers, Fractional Worded Numbers, Magnitude Suffixes, Slang Terms, Regional Formats) are reused within `parseSingleValue` to handle the different formats.",
        "testStrategy": "1. **Unit Tests for `parseSingleValue` with Mixed Formats:**\n    * Test with various input strings containing mixed formats in range expressions (e.g., \"10k - 1M\", \"ten to 100 dollars\", \"$50 - 100\", \"50 - 100 bucks\", \"five to 100\").\n    * Test with different range separators (e.g., \"to\", \"-\", \"–\") used with mixed formats.\n    * Test with currency symbols on the first value only (e.g., \"$50 - 100\", \"€20 - 30\").\n    * Test with magnitude suffixes on one or both values (e.g., \"10k - 1M\", \"10 - 1M\").\n2. **Integration Tests for Range Parsing:**\n    * Write integration tests to verify that the range parsing logic correctly handles mixed formats and returns the expected `RangeParseResult` object.\n    * Ensure that the `min`, `max`, and `currency` properties of the `RangeParseResult` object are correctly populated.",
        "status": "pending",
        "dependencies": [
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          45,
          46
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Implement Range Validation in ranges.ts",
        "description": "Implement validation logic in `ranges.ts` to ensure that the minimum value of a range is less than the maximum value, throwing a `MoneyParseError` if the range is invalid. This validation should be called within the `parseRange` function before returning the results.",
        "details": "1.  **Locate `ranges.ts`:** Open the `src/patterns/ranges.ts` file.\n2.  **Implement `validateRange` Function:** Create a new function `validateRange(min: number | null, max: number | null): void` within `ranges.ts`. This function should:\n    *   Check if both `min` and `max` are not `null`.\n    *   If both are numbers, compare `min` and `max`. If `min >= max`, throw a `MoneyParseError` with a descriptive message: \"Invalid range: min (X) must be less than max (Y)\", where X and Y are the actual values of min and max.\n3.  **Integrate `validateRange` in `parseRange`:** Modify the `parseRange` function to call `validateRange(min, max)` before returning the `RangeParseResult`. This ensures that all parsed ranges are validated before being returned.\n4.  **MoneyParseError:** Ensure that MoneyParseError is properly imported and used.",
        "testStrategy": "1.  **Unit Tests for `validateRange`:**\n    *   Create a new test file or add to an existing one for range parsing.\n    *   Write unit tests to cover the following cases:\n        *   Valid range: `min` less than `max` (e.g., `validateRange(10, 20)` should not throw an error).\n        *   Invalid range: `min` greater than `max` (e.g., `validateRange(20, 10)` should throw a `MoneyParseError` with the correct message).\n        *   Invalid range: `min` equal to `max` (e.g., `validateRange(10, 10)` should throw a `MoneyParseError` with the correct message).\n        *   `min` is `null`, `max` is a number (e.g., `validateRange(null, 20)` should not throw an error).\n        *   `min` is a number, `max` is `null` (e.g., `validateRange(10, null)` should not throw an error).\n        *   Both `min` and `max` are `null` (e.g., `validateRange(null, null)` should not throw an error).\n2.  **Integration Tests for `parseRange`:**\n    *   Write integration tests that call `parseRange` with various range strings.\n    *   Verify that `parseRange` throws a `MoneyParseError` when given an invalid range string (e.g., \"$20 - $10\").\n    *   Verify that `parseRange` returns a valid `RangeParseResult` when given a valid range string (e.g., \"$10 - $20\").",
        "status": "pending",
        "dependencies": [
          45,
          44,
          47
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Implement matchRange function for pipeline integration in ranges.ts",
        "description": "Implement the `matchRange(input: string): RangeParseResult | null` function in `ranges.ts` to find and parse a range from a string. This function will be used by the rangeDetectionStep in the pipeline and should return null if no range is found.",
        "details": "1.  **Locate `ranges.ts`:** Open the `src/patterns/ranges.ts` file.\n2.  **Implement `matchRange` Function:** Implement the `matchRange` function with the following signature: `matchRange(input: string): RangeParseResult | null`.\n3.  **Normalize Input:** Use the `normalizeInput` helper function (Task 45) to normalize the input string.\n4.  **Range Detection Logic:** Implement logic to detect if the input string contains a range. This might involve checking for range separators (using `rangeSeparatorRegex` from Task 45) or other patterns indicative of a range.\n5.  **Parsing Logic:** If a range is detected, use the existing range parsing logic (including `parseSingleValue` from Task 46 and symbol-based range parsing from Task 47) to extract the minimum and maximum values of the range.\n6.  **Return Value:**\n    *   If a range is successfully parsed, return a `RangeParseResult` object (as defined in Task 44) containing the `min`, `max`, `currency`, and `raw` values.\n    *   If no range is found, return `null`.\n7.  **Error Handling:** Handle any potential errors during parsing (e.g., invalid range format) gracefully. Consider logging errors or returning a specific error code in the `RangeParseResult` (if applicable).\n8.  **Integration with Pipeline:** Ensure the `matchRange` function is designed to be easily integrated into the regex pipeline as a range detection step.",
        "testStrategy": "1.  **Unit Tests for `matchRange`:**\n    *   Create a new test file or add to an existing one for range parsing.\n    *   Write unit tests to cover the following cases:\n        *   Valid ranges with various formats (e.g., \"$500 - $1000\", \"50 to 100 USD\", \"10k - 1M\", \"five to ten dollars\").\n        *   Ranges with different range separators (e.g., \"-\", \"–\", \"to\", \"through\").\n        *   Ranges with currency symbols on both values, only on the first value, or no currency symbols.\n        *   Invalid ranges (e.g., \"100 - 50\", where min > max). These should be handled gracefully (e.g., by throwing an error or returning null).\n        *   Input strings that do not contain a range. These should return `null`.\n        *   Edge cases and boundary conditions.\n2.  **Integration Tests:**\n    *   Create integration tests to verify that the `matchRange` function can be seamlessly integrated into the regex pipeline.\n    *   Test with various input strings to ensure the pipeline correctly identifies and parses ranges using the `matchRange` function.",
        "status": "pending",
        "dependencies": [
          44,
          45,
          46,
          47,
          53,
          54
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Extend PipelineContext with Range Fields",
        "description": "Extend the PipelineContext interface in regexPipeline.ts with isRange, min, and max fields to support range expression detection. These fields will be populated when a range expression is identified during parsing.",
        "details": "1.  **Locate `regexPipeline.ts`:** Open the `src/regexPipeline.ts` file.\n2.  **Extend `PipelineContext` Interface:** Modify the `PipelineContext` interface to include the following properties:\n    *   `isRange?: boolean` - Indicates whether the parsed value is a range (true) or a single value (false). Defaults to `false` if not present.\n    *   `min?: number` - The minimum value of the range. Only populated if `isRange` is `true`.\n    *   `max?: number` - The maximum value of the range. Only populated if `isRange` is `true`.\n3.  **Conditional Population:** Ensure that these new fields are only populated when a range expression is detected during the parsing process. The `isRange` field should be set to `true`, and the `min` and `max` fields should contain the parsed minimum and maximum values, respectively.\n4.  **Default Values:** If a range is not detected, these fields should remain undefined or their default values should be used (i.e., `isRange` should be `false`, and `min` and `max` should be undefined or null).\n5.  **Type Safety:** Ensure that the types for `min` and `max` are consistent with the existing numeric parsing logic (likely `number | null`).",
        "testStrategy": "1.  **Unit Tests for `PipelineContext` Extension:**\n    *   Create or modify existing unit tests to verify that the `PipelineContext` interface is correctly extended with the `isRange`, `min`, and `max` properties.\n    *   Verify that the types of these properties are as expected (`isRange: boolean`, `min: number | null`, `max: number | null`).\n2.  **Integration Tests with Range Parsing:**\n    *   Create integration tests that simulate the parsing of range expressions. These tests should:\n        *   Parse a valid range expression (e.g., \"$50 - $100\").\n        *   Assert that the `isRange` field in the `PipelineContext` is set to `true`.\n        *   Assert that the `min` and `max` fields contain the correct minimum and maximum values (50 and 100, respectively).\n        *   Assert that the currency is correctly parsed and stored in the context, if applicable.\n    *   Create integration tests that simulate the parsing of single values. These tests should:\n        *   Parse a single value (e.g., \"$50\").\n        *   Assert that the `isRange` field in the `PipelineContext` is either `false` or undefined.\n        *   Assert that the `min` and `max` fields are either `null` or undefined.\n3.  **Error Handling Tests:**\n    *   Create tests to ensure that the parsing logic handles invalid range expressions gracefully (e.g., \"$100 - $50\"). The `min` and `max` values should not be populated if the range is invalid, or an error should be thrown, depending on the desired behavior.\n4.  **Regression Tests:**\nEnsure that existing tests continue to pass after the changes, to avoid breaking existing functionality.",
        "status": "pending",
        "dependencies": [
          44,
          55,
          54,
          53,
          52,
          51
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Implement rangeDetectionStep in regexPipeline.ts",
        "description": "Implement a new pipeline step that detects range expressions and sets isRange, min, max, and currency on the context. This step should run BEFORE numericDetectionStep to prevent partial parsing of ranges.",
        "details": "1.  **Locate `regexPipeline.ts`:** Open the `src/regexPipeline.ts` file.\n2.  **Import `matchRange`:** Import the `matchRange` function from `src/patterns/ranges.ts`.\n3.  **Create `rangeDetectionStep` Function:** Implement a new function `rangeDetectionStep(context: PipelineContext): PipelineContext`.\n4.  **Range Detection Logic:** Inside `rangeDetectionStep`, call `matchRange(context.input)` to attempt to parse a range from the input string.\n5.  **Update Context on Success:** If `matchRange` returns a non-null `RangeParseResult`:\n    *   Set `context.isRange` to `true`.\n    *   Set `context.min` to `RangeParseResult.min`.\n    *   Set `context.max` to `RangeParseResult.max`.\n    *   Set `context.currency` to `RangeParseResult.currency`.\n    *   Update `context.value` to represent the range (e.g., string representation like \"min - max\").\n6.  **Return Context:** Return the updated `context`.\n7.  **Integrate into Pipeline:** Insert `rangeDetectionStep` into the regex pipeline in `regexPipeline.ts` BEFORE `numericDetectionStep`.",
        "testStrategy": "1.  **Unit Tests for `rangeDetectionStep`:**\n    *   Create new unit tests or modify existing ones to test the `rangeDetectionStep` function.\n    *   Test with various input strings containing range expressions (e.g., \"$500 - $1000\", \"50 to 100 USD\", \"10k - 1M\").\n    *   Verify that the `context.isRange`, `context.min`, `context.max`, and `context.currency` properties are correctly set when a range is detected.\n    *   Test with input strings that do not contain range expressions. Verify that `context.isRange` remains `undefined` or `false`, and `context.min` and `context.max` remain `undefined`.\n    *   Test that the `rangeDetectionStep` is executed before the `numericDetectionStep` and that the numeric detection step does not interfere with the range parsing.\n2.  **Integration Tests:**\n    *   Run integration tests to ensure that the entire pipeline, including the new `rangeDetectionStep`, correctly parses range expressions and produces the expected output.",
        "status": "pending",
        "dependencies": [
          7,
          9,
          55,
          56
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Integrate rangeDetectionStep into default pipeline and update numericDetectionStep",
        "description": "Integrate the rangeDetectionStep into the default regex pipeline and update the numericDetectionStep to skip processing if a range is detected.",
        "details": "1.  **Locate `regexPipeline.ts`:** Open the `src/regexPipeline.ts` file.\n2.  **Update `RegexPipeline.default()`:** Modify the `RegexPipeline.default()` method to include `rangeDetectionStep` after `currencyDetectionStep` but before `numericDetectionStep`.\n3.  **Update `numericDetectionStep`:** Modify the `numericDetectionStep` function to check `ctx.isRange`. If `ctx.isRange` is true, skip the numeric detection processing and return the context without modifications.\n4.  **Ensure correct order:** Verify that the pipeline steps are executed in the correct order: currency detection, range detection, then numeric detection (only if not a range).\n5.  **Handle defaultCurrency:** Ensure that the `defaultCurrency` option is correctly propagated through the pipeline and used in the `rangeDetectionStep` if no currency is detected in the range.",
        "testStrategy": "1.  **Unit Tests for Pipeline Integration:**\n    *   Create new unit tests or modify existing ones to test the integration of `rangeDetectionStep` into the `RegexPipeline.default()` method.\n    *   Test with various input strings containing range expressions (e.g., \"$500 - $1000\", \"50 to 100 USD\", \"10k - 1M\").\n    *   Verify that the `rangeDetectionStep` is executed before `numericDetectionStep`.\n    *   Verify that the `numericDetectionStep` is skipped when `ctx.isRange` is true.\n2.  **Unit Tests for `numericDetectionStep` Skipping:**\n    *   Create unit tests specifically to verify that `numericDetectionStep` correctly skips processing when `ctx.isRange` is true.\n    *   Test with input strings that would normally be parsed by `numericDetectionStep` but are now part of a range (e.g., \"1000\" in the context of \"$500 - $1000\").\n3.  **End-to-End Tests:**\n    *   Create end-to-end tests that use the `parseMoney()` function with range inputs to ensure the entire pipeline works correctly with the new integration.\n    *   Verify that the correct values and currencies are extracted from range expressions.\n    *   Verify that the `defaultCurrency` option is correctly applied when no currency is detected in the range.\n4.  **Test with Regional Formats:**\n    *   Include tests with regional number formats to ensure compatibility with the `regionalFormatDetectionStep`.\n5.  **Regression Tests:**\n    *   Run existing unit tests to ensure that the changes do not introduce any regressions in the existing functionality.",
        "status": "pending",
        "dependencies": [
          7,
          57,
          56,
          40
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Update parseAll.ts with range patterns",
        "description": "Add range-specific regex patterns to the MONETARY_PATTERNS array in `parseAll.ts` to detect ranges in text, ensuring ranges are detected as single expressions.",
        "details": "1.  **Locate `parseAll.ts`:** Open the `src/parseAll.ts` file.\n2.  **Import necessary modules:** Ensure that the necessary modules for range parsing (e.g., `matchRange` from `src/patterns/ranges.ts`) are imported.\n3.  **Update `MONETARY_PATTERNS`:** Modify the `MONETARY_PATTERNS` array to include new regex patterns that specifically target range expressions. These patterns should cover:\n    *   Symbol ranges (e.g., \"$500 - $1000\")\n    *   ISO code ranges (e.g., \"USD 500 - USD 1000\")\n    *   Magnitude suffix ranges (e.g., \"10k - 1M\")\n    *   Between/from contextual phrases (e.g., \"between $100 and $200\", \"from $50 to $100\")\n4.  **Ensure correct pattern order:** Place the range patterns in the `MONETARY_PATTERNS` array BEFORE any single-value patterns to prevent partial parsing of ranges. This is crucial for correct detection.\n5.  **Test range pattern integration:** Add unit tests to verify that the new range patterns are correctly integrated into the `parseAll` function and that ranges are detected as single expressions.\n6.  **Refactor if necessary:** If the existing `parseAll` logic needs adjustments to handle ranges correctly, refactor the code to accommodate the new patterns.\n7.  **Consider performance:** Ensure that the addition of new regex patterns does not significantly degrade the performance of the `parseAll` function. Optimize the patterns if necessary.",
        "testStrategy": "1.  **Unit Tests for Range Detection:**\n    *   Create new unit tests or modify existing ones to test the `parseAll` function with various input strings containing range expressions.\n    *   Test with different range formats, including:\n        *   Symbol ranges: \"$500 - $1000\", \"€50 - €100\"\n        *   ISO code ranges: \"USD 500 - USD 1000\", \"GBP 50 - GBP 100\"\n        *   Magnitude suffix ranges: \"10k - 1M\", \"5m - 10m\"\n        *   Contextual phrases: \"between $100 and $200\", \"from $50 to $100\"\n        *   Mixed formats: \"$50 - 100\", \"ten to 100 dollars\"\n    *   Verify that the `parseAll` function correctly identifies and parses the entire range expression as a single unit.\n    *   Verify that the `isRange` flag is set correctly in the `ParseResult` object.\n    *   Verify that the `min` and `max` values are correctly extracted from the range.\n    *   Verify that the currency is correctly identified for each range.\n2.  **Integration Tests:**\n    *   Create integration tests with strings containing multiple monetary expressions, including both single values and ranges (e.g., \"I have $100 and a range of $500 - $1000\").\n    *   Verify that all instances are found and parsed correctly into an array of `ParseResult` objects.\n3.  **Performance Tests:**\n    *   Run performance tests to ensure that the addition of new regex patterns does not significantly impact the performance of the `parseAll` function.\n    *   Optimize the patterns if necessary to maintain acceptable performance.",
        "status": "pending",
        "dependencies": [
          22,
          55,
          57,
          58,
          47,
          52,
          51,
          53
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Export range functions from index.ts",
        "description": "Add exports for RangeParseResult interface, parseRange function, and matchRange function from patterns/ranges.ts to the public API.",
        "details": "1. Open `src/index.ts`.\n2. Add the following exports:\n   - `export { RangeParseResult } from './types';`\n   - `export { parseRange } from './patterns/ranges';`\n   - `export { matchRange } from './patterns/ranges';`\n3. Ensure that the exported functions and interface are correctly re-exported from the main entry point of the library.",
        "testStrategy": "1.  Verify that `RangeParseResult`, `parseRange`, and `matchRange` are accessible when importing the library.\n2.  Write a test file (e.g., `index.test.ts`) to import the functions and interface from the main entry point.\n3.  Use the imported functions and interface in a simple test case to ensure they are correctly exported and functional.\n4. Run the tests to confirm the exports are working as expected.",
        "status": "pending",
        "dependencies": [
          44,
          55
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "Create unit tests for symbol-based ranges",
        "description": "Create test/patterns/ranges.test.ts with tests for symbol-based range parsing: \"$500 - $1000\", \"$500-$1000\", \"$500 to $1000\", \"€50 - €100\", \"$500 - 1000\" (symbol on first only). Test both parseRange and matchRange functions.",
        "details": "1.  **Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create separate test suites (using `describe`) for `parseRange` and `matchRange`.\n4.  **Implement test cases:** Within each test suite, implement test cases (using `it`) for the following scenarios:\n    *   Ranges with currency symbols on both values (e.g., \"$500 - $1000\", \"€50 - €100\").\n    *   Ranges with a currency symbol only on the first value (e.g., \"$500 - 1000\").\n    *   Ranges with different separators (e.g., \"$500 - $1000\", \"$500-$1000\", \"$500 to $1000\").\n    *   Ranges with different currency symbols (e.g., \"$500 - $1000\", \"€50 - €100\").\n    *   Invalid ranges (e.g., missing separator, invalid currency symbol).\n5.  **Assert correct parsing:** In each test case, assert that the `parseRange` function returns the correct `RangeParseResult` object, with the correct `min`, `max`, and `currency` values.  For `matchRange`, assert that it returns true if the input matches the expected pattern and false otherwise.\n6.  **Consider edge cases:** Include test cases for edge cases such as very large numbers, very small numbers, and numbers with different decimal separators.\n7.  **Re-use existing symbol parsing logic:** Ensure that the tests validate that the existing symbol parsing logic (from Task 12) is being correctly re-used within the range parsing logic.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the symbol-based range parsing is working correctly.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests cover all relevant code paths in the `parseRange` and `matchRange` functions.\n4.  **Manual testing:** Manually test the parsing logic with a variety of input strings to ensure that it handles different scenarios correctly.\n5.  **Regression testing:** After making any changes to the parsing logic, re-run the tests to ensure that no existing functionality has been broken.",
        "status": "pending",
        "dependencies": [
          12,
          45,
          47
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 62,
        "title": "Create unit tests for ISO code ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for ISO code range parsing, verifying correct currency code extraction and amount parsing.",
        "details": "1.  **Locate `test/patterns/ranges.test.ts`:** Find the file `test/patterns/ranges.test.ts`. If it doesn't exist, create it.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create separate test suites (using `describe`) for `parseRange` and `matchRange` if they don't already exist. If the suites exist, add the new tests to the existing suites.\n4.  **Implement test cases:** Within each test suite, add the following test cases using `it`:\n    *   `\"100 - 200 USD\"`: Verify that `parseRange` and `matchRange` correctly parse the minimum value (100), maximum value (200), and currency code (USD).\n    *   `\"100-200 EUR\"`: Verify that `parseRange` and `matchRange` correctly parse the minimum value (100), maximum value (200), and currency code (EUR).\n    *   `\"USD 100 - 200\"`: Verify that `parseRange` and `matchRange` correctly parse the minimum value (100), maximum value (200), and currency code (USD).\n    *   `\"EUR 100 to 200\"`: Verify that `parseRange` and `matchRange` correctly parse the minimum value (100), maximum value (200), and currency code (EUR).\n5.  **Use `expect` for assertions:** Use `expect` to assert that the parsed values and currency codes match the expected values. Ensure that both `parseRange` and `matchRange` return the same results for each test case.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the ISO code range parsing is working correctly.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests cover the relevant code paths in `src/patterns/ranges.ts`.\n4.  **Manual Verification:** Manually inspect the test results to ensure that the parsed values and currency codes are correct for each test case.",
        "status": "pending",
        "dependencies": [
          12,
          13,
          45,
          48,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 63,
        "title": "Create unit tests for magnitude suffix ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for magnitude suffix range parsing, verifying correct multiplier application for ranges like \"10k - 20k\", \"200k - 1M\", \"1M - 2M\", \"$10k - $20k\", and \"10k - 20k USD\".",
        "details": "1.  **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create a new test suite (using `describe`) specifically for magnitude suffix ranges.\n4.  **Implement test cases:** Within the test suite, implement test cases (using `it`) for the following scenarios:\n    *   \"10k - 20k\"\n    *   \"200k - 1M\"\n    *   \"1M - 2M\"\n    *   \"$10k - $20k\"\n    *   \"10k - 20k USD\"\n    *   Ensure tests cover both `parseRange` and `matchRange` functions.\n5.  **Verify correct multiplier application:** Each test case should assert that the parsed range values have the correct multiplier applied based on the magnitude suffix (e.g., 'k' for thousand, 'M' for million).\n6.  **Handle currency symbols:** Ensure that the tests correctly handle currency symbols within the ranges, both when present on one or both values.\n7.  **Consider edge cases:** Add tests for edge cases such as zero values, negative values (if applicable), and very large magnitude values.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the magnitude suffix range parsing is working correctly.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests provide adequate coverage of the `parseRange` and `matchRange` functions, especially the parts dealing with magnitude suffixes.\n4.  **Manual inspection:** Manually inspect the test results and the parsed values to ensure that the multipliers are being applied correctly and that the currency symbols are being handled as expected.",
        "status": "pending",
        "dependencies": [
          12,
          16,
          45,
          49,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 64,
        "title": "Create unit tests for slang term ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for slang term range parsing, verifying currency inference from slang terms like \"500 to 1000 bucks\", \"50 - 100 quid\", and \"five to ten bucks\".",
        "details": "1.  **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create a new test suite (using `describe`) specifically for slang term ranges.\n4.  **Implement test cases:** Within the slang term range test suite, implement the following test cases:\n    *   \"500 to 1000 bucks\": Verify that the range is correctly parsed, with a minimum value of 500, a maximum value of 1000, and the currency inferred as USD.\n    *   \"50 - 100 quid\": Verify that the range is correctly parsed, with a minimum value of 50, a maximum value of 100, and the currency inferred as GBP.\n    *   \"five to ten bucks\": Verify that the range is correctly parsed, with a minimum value of 5, a maximum value of 10, and the currency inferred as USD. Ensure that worded numbers are correctly parsed within the range.\n    *   Test variations of the above with different range separators (e.g., \"to\", \"-\", \"–\").\n5.  **Test both `parseRange` and `matchRange`:** Ensure that the tests cover both the `parseRange` and `matchRange` functions to verify their correct behavior with slang term ranges.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the slang term range parsing is working correctly and that the currency is correctly inferred.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests provide adequate coverage of the `parseRange` and `matchRange` functions, especially the parts dealing with slang terms.\n4.  **Manual inspection:** Manually inspect the parsed results in case of test failures to ensure that the values and currencies are being extracted and interpreted correctly.",
        "status": "pending",
        "dependencies": [
          12,
          17,
          45,
          50,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 65,
        "title": "Create unit tests for worded number ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for worded number range parsing: \"five to ten dollars\", \"one hundred to two hundred euros\", \"fifty to one hundred pounds\". Verify worded number conversion.",
        "details": "1.  **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create a new test suite (using `describe`) specifically for worded number ranges.\n4.  **Implement test cases:** Within the worded number ranges test suite, add test cases for the following scenarios:\n    *   \"five to ten dollars\"\n    *   \"one hundred to two hundred euros\"\n    *   \"fifty to one hundred pounds\"\n    *   Variations of the above with different range separators (e.g., \"five - ten dollars\", \"one hundred – two hundred euros\")\n    *   Test both `parseRange` and `matchRange` functions with the above test cases.\n5.  **Verify Worded Number Conversion:** Ensure that the tests assert the correct numeric values are extracted from the worded numbers (e.g., \"five\" is converted to 5, \"ten\" is converted to 10).\n6.  **Verify Currency Detection:** Ensure that the tests assert the correct currency is detected for each range (e.g., \"dollars\" is mapped to USD, \"euros\" is mapped to EUR, \"pounds\" is mapped to GBP).",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the worded number range parsing is working correctly and that the currency is correctly detected and the worded numbers are correctly converted.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests cover the relevant code paths in `src/patterns/ranges.ts`.\n4.  **Manual Inspection:** Manually inspect the test results to ensure that the parsed values and currencies are correct for all test cases.",
        "status": "pending",
        "dependencies": [
          12,
          14,
          45,
          51,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 66,
        "title": "Create unit tests for contextual phrase ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for contextual phrase range parsing: \"between $100 and $200\", \"from $50 to $100\", \"anywhere from 10k to 20k\". Verify \"between X and Y\" and \"from X to Y\" patterns.",
        "details": "1.  **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create a new test suite (using `describe`) specifically for contextual phrase ranges.\n4.  **Implement test cases:** Within the test suite, implement the following test cases:\n    *   Test cases for \"between X and Y\" patterns with different currency symbols/codes, number formats, and whitespace variations (e.g., \"between $100 and $200\", \"between  €50 and €100\", \"between USD 100 and 200\", \"between 100 and 200 CAD\").\n    *   Test cases for \"from X to Y\" patterns with similar variations (e.g., \"from $50 to $100\", \"from  €25 to €75\", \"from USD 50 to 100\", \"from 50 to 100 CAD\").\n    *   Test cases for \"anywhere from X to Y\" patterns with similar variations (e.g., \"anywhere from 10k to 20k\", \"anywhere from $100 to $200\", \"anywhere from  €50 to €100\", \"anywhere from USD 100 to 200\", \"anywhere from 100 to 200 CAD\").\n    *   Test cases with X and Y being worded numbers (e.g., \"between one hundred and two hundred dollars\").\n    *   Test cases with X and Y using magnitude suffixes (e.g., \"between 10k and 20k\", \"from 1M to 2M\").\n    *   Test cases with mixed number formats (e.g., \"between $100 and two hundred dollars\").\n5.  **Call `parseRange` and `matchRange`:**  Use both `parseRange` and `matchRange` functions to test the parsing.\n6.  **Verify results:** Ensure that the parsed `min`, `max`, and `currency` values are correct for each test case.  Pay attention to the correct extraction and conversion of monetary values and currency codes.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the contextual phrase range parsing is working correctly and that the currency is correctly detected.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the new parsing logic is adequately covered by the tests.\n4.  **Manual Verification:** Manually verify the parsing with a variety of input strings to ensure robustness and accuracy.",
        "status": "pending",
        "dependencies": [
          12,
          45,
          52,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 67,
        "title": "Create unit tests for mixed format ranges",
        "description": "Add tests to test/patterns/ranges.test.ts for mixed format range parsing: \"10k - 1M\" (different magnitudes), \"ten to 100 dollars\" (worded + numeric), \"$50 - 100\" (symbol on one side). Verify parser handles heterogeneous formats.",
        "details": "1. **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2. **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3. **Define test suites:** Create a new test suite (using `describe`) specifically for mixed format ranges.\n4. **Implement test cases:** Within the test suite, implement the following test cases:\n    *   Test case for \"10k - 1M\": Verify that the parser correctly interprets the range with different magnitude suffixes.\n    *   Test case for \"ten to 100 dollars\": Verify that the parser correctly handles the combination of worded and numeric values.\n    *   Test case for \"$50 - 100\": Verify that the parser correctly handles currency symbols on only one side of the range.\n    *   Test case for \"50 - 100 bucks\": Verify that the parser correctly handles slang terms on only one side of the range.\n    *   Test case for \"five to 100\": Verify that the parser correctly handles worded numbers on one side and numeric on the other.\n5. **Use `parseRange` and `matchRange`:** Test both `parseRange` and `matchRange` functions with the defined test cases.\n6. **Assert correct values:** Ensure that the parsed `min` and `max` values are correct for each test case. Also, verify that the correct currency is detected (if applicable).",
        "testStrategy": "1. **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2. **Verify test results:** Ensure that all tests pass, indicating that the mixed format range parsing is working correctly.\n3. **Check code coverage:** Use a code coverage tool to ensure that the tests cover the relevant parts of the `parseRange` and `matchRange` functions, especially the parts that handle mixed formats.\n4. **Manual inspection:** Manually inspect the test results to ensure that the parsed values and currencies are correct for each test case.",
        "status": "pending",
        "dependencies": [
          12,
          14,
          15,
          16,
          17,
          45,
          53,
          61,
          63,
          65
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 68,
        "title": "Create unit tests for range validation errors",
        "description": "Add tests to test/patterns/ranges.test.ts for validation error cases, including min > max, currency inconsistencies, same values, and overflow checks.",
        "details": "1.  **Locate/Create `test/patterns/ranges.test.ts`:** If it doesn't exist, create a new file `test/patterns/ranges.test.ts`. Otherwise, locate the existing file.\n2.  **Import necessary modules:** Import the `parseRange` and `matchRange` functions from `src/patterns/ranges.ts`, the `MoneyParseError` class (if it exists, or define a mock), as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create a new test suite (using `describe`) specifically for range validation errors.\n4.  **Implement test cases:** Within the test suite, implement the following test cases:\n    *   **Min > Max Error:** Test cases like \"1000 - 500 USD\" should throw a `MoneyParseError` indicating that the minimum value is greater than the maximum value.  Ensure the error message is descriptive.\n    *   **Currency Mismatch Error:** Test cases like \"$100 - €200\" should either throw a `MoneyParseError` or consistently use the first currency (USD in this case). Add a configuration option to control this behavior if needed. Test both scenarios.\n    *   **Same Values:** Test edge cases where the minimum and maximum values are the same (e.g., \"100 - 100 USD\").  Determine the desired behavior (should it be valid or invalid?) and implement the corresponding test.\n    *   **Overflow Checks:** Test cases with very large numbers that could potentially cause integer overflow issues during parsing or validation.  Ensure that the code handles these cases gracefully, either by throwing an error or by producing a valid result within the representable range.\n5.  **Implement Mock `MoneyParseError` (if needed):** If `MoneyParseError` is not available during testing, create a mock class that mimics its behavior for testing purposes.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass or fail as expected, indicating that the range validation is working correctly.\n3.  **Check error messages:** Verify that the error messages thrown by the validation logic are clear, descriptive, and provide sufficient information for debugging.\n4.  **Code Coverage:** Use a code coverage tool to ensure that the validation logic in `ranges.ts` is adequately covered by the tests.",
        "status": "pending",
        "dependencies": [
          45,
          54,
          61
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 69,
        "title": "Create parseMoney integration tests for ranges",
        "description": "Create integration tests for parseMoney() with range inputs to verify correct range parsing behavior. This includes verifying the isRange flag, min and max values, amount being undefined, currency detection, and defaultCurrency option handling.",
        "details": "1.  **Create `test/parseMoney.range.test.ts`:** Create a new file `test/parseMoney.range.test.ts`.\n2.  **Import necessary modules:** Import the `parseMoney` function from `src/parseMoney.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create separate test suites (using `describe`) for different range input scenarios.\n4.  **Implement test cases:** Within each test suite, implement test cases (using `it`) to cover the following:\n    *   **isRange flag:** Verify that the `isRange` flag is set to `true` in the parsed result.\n    *   **min and max values:** Verify that the `min` and `max` properties in the parsed result contain the correct numeric values.\n    *   **amount is undefined:** Verify that the `amount` property is `undefined` or `null` in the parsed result for ranges.\n    *   **Currency detection:** Test various range inputs with different currency symbols and abbreviations to ensure that the correct currency is detected.\n    *   **defaultCurrency option:** Test range inputs with the `defaultCurrency` option to verify that the specified currency is used when no currency symbol or abbreviation is present in the input string.\n    *   **Invalid ranges:** Test cases where min >= max and ensure an error is thrown.\n5.  **Test Scenarios:**\n    *   Ranges with currency symbols on both values (e.g., \"$500 - $1000\", \"€50 - €100\").\n    *   Ranges with a currency symbol only on the first value (e.g., \"$500 - 1000\").\n    *   Ranges with currency abbreviations (e.g., \"USD 500 - 1000\", \"500 to 1000 EUR\").\n    *   Ranges with worded numbers (e.g., \"five to ten dollars\").\n    *   Ranges with magnitude suffixes (e.g., \"10k - 20k\", \"1M - 2M\").\n    *   Ranges with mixed formats (e.g., \"10k - 1M\", \"ten to 100 dollars\", \"$50 - 100\").\n    *   Ranges with contextual phrases (e.g., \"between $100 and $200\", \"from $50 to $100\").\n    *   Ranges with default currency specified (e.g., \"500 - 1000\" with `defaultCurrency: 'USD'`).\n6.  **Code Coverage:** Aim for high code coverage to ensure that all parts of the `parseMoney` function related to range parsing are thoroughly tested.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the range parsing is working correctly.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests cover a significant portion of the `parseMoney` function's range parsing logic.\n4.  **Manual testing:** Perform manual testing with various range inputs to ensure that the parsing is accurate and handles edge cases correctly.\n5.  **Review test cases:** Have another developer review the test cases to ensure that they are comprehensive and cover all relevant scenarios.",
        "status": "pending",
        "dependencies": [
          7,
          58,
          57,
          55,
          44,
          45,
          46,
          47,
          53,
          54,
          56,
          52,
          51,
          61,
          63,
          65
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 70,
        "title": "Create parseAll integration tests for ranges",
        "description": "Create integration tests for parseAll() with range inputs to verify correct range parsing behavior. This includes testing various range formats and ensuring correct start/end indices for range matches.",
        "details": "1.  **Create `test/parseAll.range.test.ts`:** Create a new file `test/parseAll.range.test.ts`.\n2.  **Import necessary modules:** Import the `parseAll` function from `src/parseAll.ts`, as well as any necessary testing utilities (e.g., `describe`, `it`, `expect` from Jest or similar).\n3.  **Define test suites:** Create separate test suites (using `describe`) for different range input scenarios.\n4.  **Implement test cases:** Within each test suite, implement test cases (using `it`) to cover the following scenarios:\n    *   Single range in text (e.g., \"The price is $50 - $100\").\n    *   Multiple ranges in text (e.g., \"The price is $50 - $100 and the shipping is $10 - $20\").\n    *   Mix of ranges and single values (e.g., \"The price is $50 - $100 and the tax is $5\").\n    *   Overlapping match handling (e.g., ensure that ranges are not double-counted or incorrectly parsed when they overlap).\n    *   Correct start/end indices for range matches: Verify that the `ParseResult` objects returned by `parseAll` have the correct `start` and `end` indices for each range found in the input string.\n5.  **Test different range formats:** Ensure that the tests cover different range formats, including:\n    *   Symbol ranges (e.g., \"$500 - $1000\", \"€50 - €100\").\n    *   ISO code ranges (e.g., \"USD 500 - USD 1000\").\n    *   Ranges with different separators (e.g., \"50 to 100\", \"50-100\").\n    *   Ranges with mixed formats (e.g., \"10k - 1M\").\n6.  **Handle defaultCurrency option:** Test how the `defaultCurrency` option affects range parsing when no currency symbol or code is present in the input string.\n7.  **Consider edge cases:** Include tests for edge cases, such as empty input strings, strings with no monetary expressions, and strings with invalid range formats.",
        "testStrategy": "1.  **Run all tests:** Execute the test suite using your testing framework (e.g., `npm test`).\n2.  **Verify test results:** Ensure that all tests pass, indicating that the range parsing is working correctly.\n3.  **Check code coverage:** Use a code coverage tool to ensure that the tests cover a significant portion of the `parseAll` function's range parsing logic.\n4.  **Manual inspection:** Manually inspect the test results to ensure that the `start` and `end` indices are correctly calculated for each range match.\n5.  **Test with different locales:** If locale-specific range parsing is supported, test with different locales to ensure that the range parsing is working correctly for different regional formats.",
        "status": "pending",
        "dependencies": [
          7,
          22,
          59,
          69
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 71,
        "title": "Add range examples to demo site",
        "description": "Update the demo site (demo/src/) to include range parsing examples in the example prompts UI. Update the output panel to display isRange, min, max fields.",
        "details": "1.  **Update Example Prompts:** Modify the `ExamplePrompts.vue` component (or equivalent) in the `demo/src/` directory to include range parsing examples in the array of example prompts. Add examples such as: \"$500 to $1000\", \"200k - 1M USD\", \"between 50 and 100 euros\", \"five to ten bucks\".\n2.  **Update Output Panel:** Modify the component responsible for displaying the parsing results to include the following fields: `isRange` (boolean), `min` (number), and `max` (number). These fields should be displayed only when `isRange` is true in the parsing result.\n3.  **Data Handling:** Ensure that the parsing result from the core library is correctly passed to the output panel component and that the `isRange`, `min`, and `max` fields are extracted and displayed appropriately.\n4.  **Styling:** Adjust the styling of the example prompts and output panel as needed to ensure a clean and user-friendly presentation.",
        "testStrategy": "1.  **Verify Example Prompts:** Confirm that the updated `ExamplePrompts` component displays the new range examples correctly.\n2.  **Click Examples and Verify Output:** Click on each range example and verify that the input field is populated with the selected example.\n3.  **Inspect Output Panel:** Ensure that the output panel displays the `isRange` field as `true` and that the `min` and `max` fields are populated with the correct values extracted from the range. Also verify that the currency is correctly identified and displayed.\n4.  **Test with Different Range Formats:** Test with all the provided range examples to ensure that different range formats (symbols, ISO codes, worded numbers, contextual phrases) are correctly parsed and displayed.\n5.  **Verify Non-Range Inputs:** Ensure that the `isRange` field is `false` and that the `min` and `max` fields are not displayed when a non-range input is used.",
        "status": "pending",
        "dependencies": [
          37,
          59,
          58,
          57,
          55,
          44,
          45,
          46,
          47,
          53,
          56,
          52,
          51,
          70
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 72,
        "title": "Run Full Test Suite and Fix Failures",
        "description": "Execute the complete test suite to identify and resolve any failing tests or type errors. Ensure that all existing tests continue to pass after the integration of range parsing functionalities.",
        "details": "1.  **Execute Test Suite:** Run the complete test suite using the command `npm test`. This will execute all unit tests, integration tests, and any other tests defined in the project.\n2.  **Analyze Test Results:** Carefully examine the test results to identify any failing tests. Pay close attention to the error messages and stack traces to understand the cause of the failures.\n3.  **Fix Failing Tests:** For each failing test, investigate the code and identify the root cause of the failure. Implement the necessary code changes to fix the bug and ensure that the test passes.\n4.  **Address Type Errors:** Check for any TypeScript type errors reported by the compiler. Resolve these errors by adjusting the code to satisfy the type checker.\n5.  **Regression Testing:** After fixing the failing tests and type errors, re-run the entire test suite to ensure that no new issues have been introduced. This is crucial to verify that the changes have not broken any existing functionality.\n6.  **Range Parsing Integration Verification:** Specifically verify that all tests related to range parsing (Tasks 47, 48, 49, 50, 51, 52, 53, 55, 57, 58, 59, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70) are passing. This includes tests for symbol-based ranges, ISO code ranges, magnitude suffix ranges, slang term ranges, worded number ranges, contextual phrase ranges, and mixed format ranges.\n7.  **Code Review:** After making the necessary changes, submit the code for review to ensure that it meets the project's quality standards.",
        "testStrategy": "1.  **Execute `npm test`:** Run the command `npm test` to execute the complete test suite.\n2.  **Verify All Tests Pass:** Ensure that all tests in the test suite pass without any failures or errors. This includes unit tests, integration tests, and any other tests defined in the project.\n3.  **Check for Type Errors:** Verify that the TypeScript compiler reports no type errors.\n4.  **Code Coverage Analysis:** Use a code coverage tool to ensure that the tests cover a significant portion of the codebase, including the newly integrated range parsing functionalities. Aim for a high percentage of code coverage to minimize the risk of undetected bugs.\n5.  **Manual Testing (Optional):** Perform manual testing of the range parsing functionalities to verify that they work as expected in real-world scenarios. This can involve entering various monetary expressions with ranges and verifying that they are parsed correctly.\n6.  **Review Test Results:** Carefully review the test results to identify any potential issues or areas for improvement. Pay attention to the performance of the tests and look for opportunities to optimize the code.",
        "status": "pending",
        "dependencies": [
          5,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          55,
          57,
          58,
          59,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 73,
        "title": "Run Build and Fix Type Errors",
        "description": "Execute the build process and resolve any resulting type errors or build failures. Verify that the built output includes range parsing exports.",
        "details": "1.  **Execute Build:** Run the command `npm run build` to compile the TypeScript code and generate the output bundles (ESM, CJS, UMD).\n2.  **Analyze Build Output:** Carefully examine the output of the build process for any type errors or build failures. Note the specific error messages and file locations.\n3.  **Fix Type Errors:** Address each type error by modifying the TypeScript code to resolve the issue. This may involve correcting type annotations, adding missing properties, or adjusting the logic of the code.\n4.  **Verify Range Parsing Exports:** Ensure that the built output includes the necessary exports for range parsing functionality. Specifically, verify that `RangeParseResult`, `parseRange`, and `matchRange` are correctly exported from the library's main entry point (`index.ts`).\n5.  **Re-run Build:** After fixing the type errors, re-run the build process to ensure that all errors have been resolved and that the build completes successfully.\n6.  **Inspect Generated Files:** Examine the generated files in the output directories (e.g., `dist/esm`, `dist/cjs`, `dist/umd`) to confirm that the range parsing exports are present and correctly formatted.",
        "testStrategy": "1.  **Execute `npm run build`:** Run the build command to generate the output bundles.\n2.  **Verify Build Success:** Ensure that the build process completes without any errors or warnings.\n3.  **Check for Range Parsing Exports:** Inspect the generated files (e.g., `dist/index.js`, `dist/index.d.ts`) to verify that `RangeParseResult`, `parseRange`, and `matchRange` are correctly exported.\n4.  **Import and Use Exports:** Create a temporary test file to import the range parsing exports from the generated bundles and use them in a simple test case. This will confirm that the exports are accessible and functional.\n5.  **Run Test Suite:** Execute the complete test suite (using `npm test`) to ensure that all existing tests continue to pass after the build process.",
        "status": "pending",
        "dependencies": [
          2,
          5,
          60,
          72
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 74,
        "title": "Update CLAUDE.md with range parsing documentation",
        "description": "Update the project documentation to include the new range parsing feature, covering supported patterns, output format, validation, and usage examples.",
        "details": "1.  **Locate `CLAUDE.md`:** Find the project documentation file `CLAUDE.md` in the repository.\n2.  **Add Range Parsing Section:** Create a new section dedicated to documenting the range parsing feature.\n3.  **Document Supported Range Patterns:**\n    *   List and describe all seven categories of supported range patterns:\n        *   Symbol ranges (e.g., \"$500 - $1000\")\n        *   ISO code ranges (e.g., \"USD 500 - USD 1000\")\n        *   Magnitude suffix ranges (e.g., \"10k - 1M\")\n        *   Slang term ranges (e.g., \"500 to 1000 bucks\")\n        *   Worded number ranges (e.g., \"five to ten dollars\")\n        *   Contextual phrase ranges (e.g., \"between $100 and $200\")\n        *   Mixed format ranges (e.g., \"10k - 1M\", \"ten to 100 dollars\", \"$50 - 100\")\n    *   Provide clear examples for each pattern category.\n4.  **Document Output Format:**\n    *   Explain the structure of the `RangeParseResult` object.\n    *   Describe the purpose and possible values of the following fields:\n        *   `isRange` (boolean): Indicates if the parsed result is a range.\n        *   `min` (number | null): The minimum value of the range.\n        *   `max` (number | null): The maximum value of the range.\n        *   `currency` (string | null): The ISO currency code, if detected.\n        *   `raw` (string): The original input string.\n5.  **Document Validation Behavior:**\n    *   Explain the validation rules applied to ranges (e.g., `min` must be less than `max`).\n    *   Describe the conditions under which a `MoneyParseError` is thrown (e.g., invalid range, currency inconsistencies).\n6.  **Provide Usage Examples:**\n    *   Show how to use `parseMoney()` and `parseAll()` with range inputs.\n    *   Include code snippets demonstrating how to extract the `min`, `max`, and `currency` values from the `RangeParseResult` object.\n7.  **Review and Edit:** Ensure the documentation is clear, concise, and accurate. Proofread for any grammatical errors or typos.",
        "testStrategy": "1.  **Verify Content:** Manually review the updated `CLAUDE.md` file to ensure that all the required information is present and accurate.\n2.  **Check Examples:** Verify that the provided examples are correct and demonstrate the intended usage of the range parsing feature.\n3.  **Validate Formatting:** Ensure that the documentation is well-formatted and easy to read.\n4.  **Build Project:** Run `npm run build` to ensure that the documentation changes do not introduce any build errors.\n5.  **Deploy Documentation:** If the documentation is deployed as part of the project website, verify that the changes are correctly reflected on the live site.",
        "status": "pending",
        "dependencies": [
          44,
          55,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-22T05:27:52.739Z",
      "updated": "2026-01-11T19:11:18.556Z",
      "description": "Tasks for master context"
    }
  }
}