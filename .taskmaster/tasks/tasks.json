{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Git Repository and Basic Structure",
        "description": "Set up the basic Git repository structure for the numis library.",
        "details": "Initialize a git repository. Create basic project directories (e.g., `src`, `test`). Add a `.gitignore` file.",
        "testStrategy": "Verify repository is initialized and basic structure is present.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure TypeScript Compiler (tsconfig.json)",
        "description": "Configure the TypeScript compiler for the project, targeting Node >= 18 and modern browsers, and enabling dual ESM/CJS output.",
        "details": "Install TypeScript. Create and configure `tsconfig.json` for dual ESM/CJS builds (e.g., using `moduleResolution`, `module`, `outDir`). Ensure compatibility with Node >= 18 and modern browsers.",
        "testStrategy": "Compile a simple test file to verify ESM and CJS output directories and file types are generated correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Configure ESLint with Airbnb-base Rules",
        "description": "Set up ESLint with the Airbnb-base configuration and integrate it into the project.",
        "details": "Install ESLint and `eslint-config-airbnb-base`. Configure ESLint via `.eslintrc.js` or similar, extending the Airbnb-base config. Add lint scripts to `package.json`.",
        "testStrategy": "Run the lint script on the codebase (once files exist) to ensure it passes without errors based on the configuration.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Configure Jest and ts-jest for Testing",
        "description": "Configure Jest and ts-jest for running tests on the TypeScript codebase.",
        "details": "Install Jest, ts-jest, and `@types/jest`. Configure Jest via `jest.config.js` to use ts-jest for `.ts` files. Add test scripts to `package.json`.",
        "testStrategy": "Write and run a simple test file (`.test.ts`) to confirm Jest and ts-jest execute correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Custom Error Classes (MoneyParseError, ValueOverflowError)",
        "description": "Implement custom error classes `MoneyParseError` and `ValueOverflowError`.",
        "details": "Define `MoneyParseError` and `ValueOverflowError` classes extending the built-in `Error` class. Include relevant properties or messages as needed for helpful errors.",
        "testStrategy": "Write simple unit tests to instantiate the error classes and verify their properties and inheritance.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate currency-codes and Implement Data Loading",
        "description": "Integrate the `currency-codes` package and implement logic to load and lookup currency data.",
        "details": "Install `currency-codes`. Implement a module to import and access currency data from the package. Consider how tree-shaking might be applied or if a custom JSON build step is needed later (optional for MVP).\n<info added on 2025-06-22T05:45:04.561Z>\nImplementation plan:\n1. Create `src/currencyData.ts` module that imports the `currency-codes` package once and exposes lightweight lookup helpers:\n   - `getCurrencyByCode(code: string)` returns the matching currency entry or null.\n   - `getCurrencyByNumber(number: string)` returns entry or null.\n   - `getAllCurrencies()` returns the raw array for advanced use.\n   These helpers provide a simple, typed facade so the rest of the parser doesn’t touch the large `currency-codes` dataset directly. No symbol mapping yet – that belongs to later pattern-parsing tasks.\n2. Add minimal internal interface `CurrencyInfo` to capture the subset of fields we actually use (`code`, `currency`, `number`, `countries`).  Casting is fine for now; we avoid shipping any runtime wrappers so tree-shaking works.\n3. Write Jest unit tests in `test/currencyData.test.ts` that assert USD/EUR lookups work by both code and numeric ID.  This covers the success path and gives us a red flag if the package structure changes.\n4. Dependency is already declared in `package.json`; no further install step needed.\n5. No public API exposure yet – `index.ts` will re-export once the core parser is wired up.\n\nThese changes are self-contained and unblock downstream tasks that rely on currency data lookups.\n</info added on 2025-06-22T05:45:04.561Z>",
        "testStrategy": "Write unit tests to verify currency data can be loaded and specific currency codes/symbols can be looked up correctly using the implemented logic.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Core Regex Pipeline Structure",
        "description": "Implement the core structure for the regex pipeline that processes input strings.",
        "details": "Create a module or class to manage the sequence of regex checks: currency detection -> numeric/word detection -> pattern-specific parsing. Design the flow for applying these steps to an input string.",
        "testStrategy": "Create a mock pipeline with simple regex steps and verify that an input string is processed through the defined sequence.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Currency-First Detection Regex",
        "description": "Implement the currency-first detection regex logic within the pipeline.",
        "details": "Develop regex patterns to quickly scan for ISO-4217 keywords or symbols using the loaded currency data. Integrate this as the first step in the regex pipeline.",
        "testStrategy": "Write unit tests with various inputs containing currency symbols or codes (e.g., '$', 'USD', '€', 'GBP') to verify the currency detection regex correctly identifies potential currency indicators.",
        "priority": "high",
        "dependencies": [
          7,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Numeric/Word Detection Regex",
        "description": "Implement the numeric/word detection regex logic within the pipeline.",
        "details": "Develop regex patterns to identify potential numeric or worded number parts of the input string. Integrate this step after currency detection in the pipeline.",
        "testStrategy": "Write unit tests with inputs containing numbers (plain, with separators), worded numbers ('one hundred'), and numeric-word combos ('10k') to verify the numeric/word detection regex correctly identifies these parts.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Parser for Plain Numbers Pattern",
        "description": "Implement the pattern parser for Plain Numbers (e.g., '123').",
        "details": "Create a specific parser function or module for the 'Plain Numbers' pattern. This parser should take a matched substring and convert it to a numeric value.",
        "testStrategy": "Write unit tests with various plain number strings ('1', '123', '999999') to verify the parser correctly extracts and converts the numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Parser for Numbers with Separators Pattern",
        "description": "Implement the pattern parser for Numbers with Separators (e.g., '1,234.56').",
        "details": "Create a parser for numbers including thousands separators (',') and decimal points ('.'). Handle different separator conventions if necessary (though PRD doesn't specify locales yet, focus on common ones).",
        "testStrategy": "Write unit tests with strings like '1,000', '1.23', '1,234,567.89' to verify the parser correctly handles separators and converts to the correct numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create regex pattern for numbers with separators",
            "description": "Define regex pattern to match numbers with thousands separators (,) and decimal points (.)",
            "details": "Pattern should handle: 1,000 | 1,234.56 | 1,234,567.89 | Handle edge cases like leading zeros, multiple decimals",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 2,
            "title": "Implement parser function for numbers with separators",
            "description": "Create parser that removes separators and converts to numeric value",
            "details": "Strip commas, validate format, convert to number, handle invalid inputs",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 3,
            "title": "Write unit tests for numbers with separators",
            "description": "Create comprehensive test suite for the parser",
            "details": "Test cases: '1,000', '1.23', '1,234,567.89', edge cases, invalid formats",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 4,
            "title": "Integrate pattern into main parser pipeline",
            "description": "Add the new pattern to the regex pipeline in index.ts",
            "details": "Export pattern, add to pipeline, ensure proper ordering",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 5,
            "title": "Run tests and verify implementation",
            "description": "Execute test suite and validate all cases pass",
            "details": "Run jest tests, fix any failures, ensure no regressions",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Parser for Symbols Pattern",
        "description": "Implement the pattern parser for Symbols (e.g., '$100').",
        "details": "Create a parser that recognizes currency symbols attached to numbers. Use the currency data to map symbols to ISO codes.",
        "testStrategy": "Write unit tests with strings like '$100', '€50', '£20.50' to verify the parser correctly identifies the symbol, extracts the number, and maps the symbol to the correct ISO currency code.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Parser for Abbreviations Pattern",
        "description": "Implement the pattern parser for Abbreviations (e.g., 'USD 100').",
        "details": "Create a parser that recognizes ISO 4217 currency abbreviations preceding or following a number. Use the currency data for lookup.",
        "testStrategy": "Write unit tests with strings like 'USD 100', 'EUR 50', 'GBP 20.50', '100 CAD' to verify the parser correctly identifies the abbreviation, extracts the number, and maps the abbreviation to the correct ISO currency code.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Parser for Worded Numbers Pattern",
        "description": "Implement the pattern parser for Worded Numbers (e.g., 'one hundred dollars').",
        "details": "Create a parser that converts worded numbers (e.g., 'one', 'ten', 'hundred', 'thousand', 'million') into their numeric equivalents.",
        "testStrategy": "Write unit tests with strings like 'one', 'twenty', 'one hundred', 'two thousand', 'one million' to verify the parser correctly converts the worded number to a numeric value.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Parser for Fractional Worded Numbers Pattern",
        "description": "Implement the pattern parser for Fractional Worded Numbers (e.g., 'half a dollar').",
        "details": "Create a parser that handles fractional worded numbers like 'half', 'quarter', etc., potentially combined with currency.",
        "testStrategy": "Write unit tests with strings like 'half a dollar', 'quarter pound' (if applicable, focus on monetary context) to verify correct numeric conversion.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define fractional word lexicon and normalization rules",
            "description": "List supported fractional terms (e.g., half, quarter, three quarters, third/thirds) and map them to numeric values for monetary parsing. Clarify scope and assumptions.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 2,
            "title": "Implement fractional worded number parser",
            "description": "Add parser logic that converts supported fractional word patterns into numeric amounts and currency metadata, aligning with existing pattern/parser interfaces.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 3,
            "title": "Integrate parser into pipeline",
            "description": "Register the fractional worded number pattern/parser in the regex pipeline and ensure ordering doesn’t conflict with existing worded-number handling.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 4,
            "title": "Write unit tests for fractional worded numbers",
            "description": "Add fixtures covering phrases like 'half a dollar', 'quarter dollar', 'three quarters of a euro', verifying numeric conversion and currency handling.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 15
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Parser for Numeric-Word Combos Pattern",
        "description": "Implement the pattern parser for Numeric-Word Combos (e.g., '10k').",
        "details": "Create a parser that handles combinations of numbers and words representing magnitude (e.g., 'k', 'm', 'bn').",
        "testStrategy": "Write unit tests with strings like '10k', '5m', '2bn' to verify the parser correctly calculates the numeric value (10,000, 5,000,000, 2,000,000,000).",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Parser for Slang Terms Pattern",
        "description": "Implement the pattern parser for Slang Terms (e.g., 'buck', 'quid').",
        "details": "Create a parser that recognizes common slang terms for currency units and maps them to the appropriate currency and value.",
        "testStrategy": "Write unit tests with strings like 'buck', 'quid', 'fiver', 'tenner' to verify the parser correctly identifies the slang term and associated value/currency (assuming US/UK context based on examples).",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Parser for Contextual Phrases Pattern",
        "description": "Implement the pattern parser for Contextual Phrases (e.g., 'a hundred dollars') including compound major+minor currency expressions.",
        "status": "done",
        "dependencies": [
          7,
          9
        ],
        "priority": "medium",
        "details": "Create a parser that handles numbers and currencies embedded within simple phrases, potentially including articles ('a', 'the'), and now also handles compound major+minor currency expressions (e.g., 'a dollar and 23 cents', 'five euros and fifty cents').",
        "testStrategy": "Write unit tests with strings like 'a hundred dollars', 'the fifty euros', 'a dollar and 23 cents', 'five euros and fifty cents' to verify the parser extracts the core monetary expression, including major and minor units.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design contextual phrases parsing rules and data shapes",
            "description": "Define input examples, expected outputs, and parser interface for contextual phrases (articles + number + currency).",
            "status": "done",
            "dependencies": [],
            "details": "List target patterns (e.g., 'a hundred dollars', 'the fifty euros', 'one thousand yen'); clarify assumptions on article handling and ordering; update task notes if scope adjustments needed.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement contextual phrase parser",
            "description": "Code parser to extract amount and currency from phrases with articles and simple structure.",
            "status": "done",
            "dependencies": [],
            "details": "Handle patterns like '<article?> <number/worded number> <currency name/code>'; normalize case/whitespace; return amount+currency; reuse existing number and currency helpers where possible.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate parser into pipeline",
            "description": "Wire contextual phrase matching into regex/numeric pipeline with appropriate precedence.",
            "status": "done",
            "dependencies": [],
            "details": "Add matching function and hook into regexPipeline step order; ensure no regressions with other patterns.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add unit tests for contextual phrases",
            "description": "Write tests for parsing phrases like 'a hundred dollars', 'the fifty euros', 'one thousand yen'.",
            "status": "done",
            "dependencies": [],
            "details": "Cover articles, numeric/worded amounts, case/whitespace handling, invalid inputs, and pipeline integration where applicable.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Documentation and edge-case notes",
            "description": "Document supported contextual phrase patterns and limitations.",
            "status": "done",
            "dependencies": [],
            "details": "Update README or pattern docs with examples; note assumptions (articles optional, simple ordering, no complex grammar).",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Extend parser to handle major+minor currency expressions",
            "description": "Modify the parser to recognize and extract amounts from phrases like 'a dollar and 23 cents'.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Implement parsing logic for '<major currency> and <minor currency>' patterns. Ensure correct handling of different currencies and their minor units. Consider edge cases like missing major or minor units.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Update unit tests for major+minor currency expressions",
            "description": "Add new unit tests to cover the parsing of major+minor currency expressions.",
            "status": "done",
            "dependencies": [
              4,
              6
            ],
            "details": "Include tests for various scenarios, such as 'a dollar and 23 cents', 'five euros and fifty cents', '10 pounds and 5 pence', and edge cases with missing major or minor units.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Update documentation with major+minor currency examples",
            "description": "Expand the documentation to include examples and explanations of how the parser handles major+minor currency expressions.",
            "status": "done",
            "dependencies": [
              5,
              6
            ],
            "details": "Add examples to the README or pattern docs demonstrating the supported formats and limitations for major+minor currency parsing.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 19,
        "title": "Implement Parser for Regional Formats Pattern",
        "description": "Implement the pattern parser for Regional Formats (e.g., '1.234,56 €').",
        "details": "Create a parser that handles regional variations in number formatting (decimal/thousands separators) and currency symbol/code placement.",
        "testStrategy": "Write unit tests with strings like '1.234,56 €', '€ 1.234,56', '5,678.90 $' to verify the parser correctly handles regional formatting and currency association.",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Regional Format Specifications",
            "description": "Document the different regional formats to be supported, including variations in decimal separators, thousands separators, currency symbols, currency codes, and their placement (prefix/suffix).",
            "dependencies": [],
            "details": "Create a comprehensive list of regional format examples and their corresponding parsing rules. Consider edge cases and ambiguous formats.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Decimal and Thousands Separator Detection",
            "description": "Develop logic to automatically detect the decimal and thousands separators used in a given input string based on regional format specifications.",
            "dependencies": [
              1
            ],
            "details": "Implement algorithms to identify the separators based on frequency and position within the input string. Handle cases where separators are missing or ambiguous.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Currency Symbol/Code Extraction",
            "description": "Develop logic to extract the currency symbol or code from the input string, considering both prefix and suffix placement.",
            "dependencies": [
              1
            ],
            "details": "Implement pattern matching or regular expressions to identify and extract the currency symbol or code. Handle cases where the currency symbol/code is missing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Number Parsing with Regional Format Handling",
            "description": "Implement the core number parsing logic, taking into account the detected decimal and thousands separators, and the extracted currency symbol/code.",
            "dependencies": [
              2,
              3
            ],
            "details": "Convert the input string into a numerical value, correctly interpreting the separators and currency information. Handle potential parsing errors and invalid formats.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Validation and Error Handling",
            "description": "Implement validation checks to ensure the input string conforms to a valid regional format and handle potential parsing errors gracefully.",
            "dependencies": [
              4
            ],
            "details": "Add checks for invalid characters, incorrect separator placement, and other format inconsistencies. Provide informative error messages for invalid inputs.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Currency Normalisation",
        "description": "Implement currency normalisation logic using the `currency-codes` dataset.",
        "details": "Create a function or module to take a potential currency identifier (symbol, code, name) and normalize it to an ISO 4217 code using the `currency-codes` data.",
        "testStrategy": "Write unit tests with various inputs ('$', 'USD', 'Euro', 'GBP') to verify they are correctly normalized to their ISO 4217 codes ('USD', 'EUR', 'GBP'). Test cases for unknown currencies should result in an error or null/undefined output depending on implementation.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement parseMoney Function",
        "description": "Implement the `parseMoney` function, integrating the regex pipeline, pattern parsers, currency normalization, and error handling.",
        "details": "Create the `parseMoney(input: string, opts?: ParseOptions): ParseResult | null` function. This function should orchestrate the regex pipeline, apply pattern parsers to matches, normalize the currency, and return the `ParseResult` object or `null` if no match is found. Handle the `defaultCurrency` and `strict` options.",
        "testStrategy": "Write integration tests covering various input strings and options (`defaultCurrency`, `strict`) to verify correct parsing, currency normalization, and the structure of the returned `ParseResult` object or `null`.",
        "priority": "high",
        "dependencies": [
          5,
          7,
          8,
          9,
          20,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement parseAll Function",
        "description": "Implement the `parseAll` function to find all monetary expressions in a string.",
        "details": "Create the `parseAll(input: string, opts?: ParseOptions): ParseResult[]` function. This function should iterate through the input string, potentially using the `parseMoney` logic or a variation of the pipeline, to find all occurrences of monetary expressions and return an array of `ParseResult` objects.",
        "testStrategy": "Write integration tests with strings containing multiple monetary expressions (e.g., 'I have $100 and he has €50') to verify all instances are found and parsed correctly into an array of `ParseResult` objects.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Value Overflow Check and Error",
        "description": "Implement the check for numeric value exceeding `Number.MAX_SAFE_INTEGER` and throw `ValueOverflowError`.",
        "details": "Within the parsing logic (likely in individual parsers or the final value conversion step), add a check to compare the resulting numeric amount against `Number.MAX_SAFE_INTEGER`. If it exceeds this limit, throw a `ValueOverflowError`.",
        "testStrategy": "Write unit or integration tests with inputs representing numbers larger than `Number.MAX_SAFE_INTEGER` (e.g., '9007199254740992', '10 quadrillion') to verify that a `ValueOverflowError` is correctly thrown.",
        "priority": "high",
        "dependencies": [
          5,
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Write Unit Tests for Pattern Parsers (Fixtures)",
        "description": "Write comprehensive unit tests for each of the 10 pattern parsers using specific fixtures.",
        "details": "Create test files for each pattern parser. Use representative input strings (fixtures) covering various valid cases and edge cases for each pattern. Verify the parser correctly extracts the numeric value and any associated currency information.",
        "testStrategy": "Run Jest tests for all pattern parsers. Ensure tests cover a wide range of fixtures and achieve high code coverage for the parser logic.",
        "priority": "high",
        "dependencies": [
          4,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Testing Environment",
            "description": "Configure pytest and any necessary testing libraries.",
            "dependencies": [],
            "details": "Install pytest, create a pytest.ini file, and set up any required test directories.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Fixtures Directory",
            "description": "Establish a directory to store fixture data for the pattern parsers.",
            "dependencies": [
              1
            ],
            "details": "Create a 'fixtures' directory within the test directory structure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Define Fixtures for Parser 1",
            "description": "Create fixture data representing various valid and invalid inputs for the first pattern parser.",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parser 1.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Write Unit Tests for Parser 1",
            "description": "Implement pytest unit tests for the first pattern parser, utilizing the defined fixtures.",
            "dependencies": [
              3
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parser 1.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Define Fixtures for Parser 2",
            "description": "Create fixture data representing various valid and invalid inputs for the second pattern parser.",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parser 2.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Write Unit Tests for Parser 2",
            "description": "Implement pytest unit tests for the second pattern parser, utilizing the defined fixtures.",
            "dependencies": [
              5
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parser 2.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Define Fixtures for Parsers 3-10",
            "description": "Create fixture data representing various valid and invalid inputs for the remaining pattern parsers (3-10).",
            "dependencies": [
              2
            ],
            "details": "Generate JSON or YAML files containing test cases for Parsers 3 through 10.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Write Unit Tests for Parsers 3-10",
            "description": "Implement pytest unit tests for the remaining pattern parsers (3-10), utilizing the defined fixtures.",
            "dependencies": [
              7
            ],
            "details": "Write test functions that load fixture data and assert expected outputs from Parsers 3 through 10.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Run All Unit Tests",
            "description": "Execute all the created unit tests to ensure proper functionality.",
            "dependencies": [
              4,
              6,
              8
            ],
            "details": "Use pytest to run all tests in the test suite.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Analyze Test Results and Refactor",
            "description": "Review the test results, identify any failures, and refactor code or tests as needed.",
            "dependencies": [
              9
            ],
            "details": "Address any failing tests by debugging the pattern parsers or adjusting the test fixtures.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 25,
        "title": "Write Unit Tests for API Functions and Errors",
        "description": "Write unit tests for the public API functions (`parseMoney`, `parseAll`) including error handling cases.",
        "details": "Create test files for `parseMoney` and `parseAll`. Test various valid inputs, inputs with no matches, inputs triggering `MoneyParseError` (e.g., unknown currency with `strict: true`), and inputs triggering `ValueOverflowError`. Verify return values and thrown errors.",
        "testStrategy": "Run Jest tests for the API functions. Ensure tests cover successful parsing, null results, and all specified error conditions.",
        "priority": "high",
        "dependencies": [
          4,
          21,
          22,
          23
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Expand parseMoney tests for input patterns",
            "description": "Add tests to parseMoney.test.ts to cover various input patterns including symbols, ISO codes, worded numbers, and slang.",
            "dependencies": [],
            "details": "Focus on creating a diverse set of test cases that represent common and uncommon money representations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Test parseMoney edge cases",
            "description": "Add tests to parseMoney.test.ts to cover edge cases such as empty string, no match, and whitespace inputs.",
            "dependencies": [],
            "details": "Ensure that parseMoney handles these edge cases gracefully and returns the expected results or errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement ValueOverflowError testing for parseMoney",
            "description": "Add tests to parseMoney.test.ts to specifically test the ValueOverflowError when parsing extremely large numbers.",
            "dependencies": [],
            "details": "Create test cases that intentionally cause a value overflow and verify that the correct error is thrown.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Verify parseMoney return value structure",
            "description": "Add tests to parseMoney.test.ts to verify the structure of the return value, ensuring it contains the expected properties and data types.",
            "dependencies": [],
            "details": "Check that the returned object has the correct fields (e.g., amount, currency) and that their types are as expected.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement ValueOverflowError testing for parseAll",
            "description": "Add tests to parseAll.test.ts to specifically test the ValueOverflowError when parsing extremely large numbers within text.",
            "dependencies": [],
            "details": "Create test cases with large numbers embedded in text and verify that the correct error is thrown when parsing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Verify parseAll edge cases",
            "description": "Add tests to parseAll.test.ts to cover edge cases and ensure robust handling of unexpected inputs.",
            "dependencies": [],
            "details": "Focus on scenarios where the input might be malformed or incomplete, ensuring the function behaves predictably.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Property-Based Fuzzing Tests (fast-check)",
        "description": "Implement property-based fuzzing tests using `fast-check` to improve test coverage and robustness.",
        "details": "Install `fast-check`. Write property-based tests that generate random strings or structured inputs and pass them to `parseMoney` or `parseAll`. Define properties that the output should satisfy (e.g., if a number is clearly present, the amount should be numeric).",
        "testStrategy": "Run the property-based tests with a sufficient number of iterations. Analyze any failing cases to identify bugs or missing pattern handling.",
        "priority": "medium",
        "dependencies": [
          4,
          21,
          22
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install fast-check dependency",
            "description": "Install the fast-check library as a development dependency using npm or yarn.",
            "dependencies": [],
            "details": "Use `npm install --save-dev fast-check` or `yarn add --dev fast-check`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create test file structure and basic setup",
            "description": "Create a test file (e.g., `parseMoney.test.ts`) and import necessary modules from fast-check and the code to be tested.",
            "dependencies": [
              1
            ],
            "details": "Create a new test file and import `fc` from 'fast-check' and the `parseMoney` and `parseAll` functions from your codebase.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement property tests for parseMoney with random string inputs",
            "description": "Define properties for `parseMoney` that should hold true for any random string input. Focus on error handling and invariant checks.",
            "dependencies": [
              2
            ],
            "details": "Use `fc.string()` to generate random string inputs and assert that `parseMoney` either throws an error or returns a valid result based on the input string's format.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement property tests for parseAll with structured monetary inputs",
            "description": "Define properties for `parseAll` using structured monetary inputs (e.g., objects with amount and currency fields).",
            "dependencies": [
              2
            ],
            "details": "Create custom arbitraries using `fc.record` to generate structured monetary inputs. Assert that `parseAll` correctly parses these inputs and maintains expected invariants.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add edge case generators and invariant tests",
            "description": "Extend the generators to include edge cases (e.g., very large numbers, special characters) and add more comprehensive invariant tests to ensure the parsing functions behave correctly under all circumstances.",
            "dependencies": [
              3,
              4
            ],
            "details": "Use `fc.oneof` or `fc.frequency` to combine standard generators with generators for edge cases. Add assertions to verify that invariants related to the parsed values hold true.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 27,
        "title": "Configure Dual ESM/CJS Build Process",
        "description": "Configure the build process to generate dual ESM and CJS outputs from the TypeScript source.",
        "details": "Use the configured `tsconfig.json` and potentially a build tool (like Rollup or Webpack, though TS compiler might suffice) to produce separate ESM and CJS bundles or file structures in the output directory.\n<info added on 2025-06-29T17:03:14.182Z>\nImplementation plan (initial) for Dual ESM/CJS build:\n1. Add `tsconfig.cjs.json` extending base tsconfig but overriding:\n   {\n     \"extends\": \"./tsconfig.json\",\n     \"compilerOptions\": {\n       \"module\": \"CommonJS\",\n       \"outDir\": \"dist/cjs\"\n     }\n   }\n2. Retain `tsconfig.json` with ESNext module and `dist/esm` outDir.\n3. Update `package.json`:\n   - Add scripts:\n     \"clean\": \"rimraf dist\",\n     \"build:esm\": \"tsc -p tsconfig.json\",\n     \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n     \"build\": \"npm run clean && npm run build:esm && npm run build:cjs\".\n   - Add `exports` field for conditional exports:\n     {\n       \"import\": \"./dist/esm/index.js\",\n       \"require\": \"./dist/cjs/index.js\"\n     }\n   - Set `main`: \"./dist/cjs/index.js\",\n     `module`: \"./dist/esm/index.js\",\n     `types`: \"./dist/esm/index.d.ts\".\n4. Install `rimraf` as devDependency.\n5. Optionally configure `typesVersions` mapping for older TS consumers (skip for now).\n6. Verify build by running `npm run build` producing both directories and test require/import in node.\n\nNext steps:\n- Create tsconfig.cjs.json file.\n- Modify package.json scripts and exports.\n- Install rimraf.\n- Run build and adjust tests.\n- Update documentation if needed.\n</info added on 2025-06-29T17:03:14.182Z>",
        "testStrategy": "Verify the output directory contains both ESM and CJS versions of the library files. Test importing the library in a simple Node.js script using both `require()` (CJS) and `import()` (ESM).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Configure UMD Bundle Generation for Demo Site",
        "description": "Configure the build process to generate a separate minified UMD bundle specifically for the demo site.",
        "details": "Use a bundler (like Rollup or Webpack) to create a single minified UMD file from the library source. This bundle should be suitable for inclusion via a `<script>` tag.",
        "testStrategy": "Verify a single minified UMD file is generated. Create a simple HTML file with a `<script>` tag pointing to the UMD file and verify the library's public API is available on the global scope (e.g., `window.monetJs.parseMoney`).",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Configure GitHub Actions CI Pipeline (Lint, Test, Build)",
        "description": "Configure the GitHub Actions CI pipeline to run linting, testing, and building steps.",
        "details": "Create a GitHub Actions workflow file (`.github/workflows/ci.yml`). Define jobs for linting (Task 3), testing (Task 4), and building (Task 27). Configure the workflow to trigger on pushes and pull requests.",
        "testStrategy": "Push code to a GitHub repository to trigger the CI workflow. Verify that all steps (lint, test, build) pass successfully in the CI environment.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Add Size-Limit Check to CI Pipeline",
        "description": "Add a size-limit check to the CI pipeline to gate bundle size (<5 kB gzip).",
        "details": "Install `size-limit`. Configure `size-limit` to check the gzip size of the main library bundle(s). Add a step to the CI workflow to run the size-limit check.",
        "testStrategy": "Run the CI workflow. Verify the size-limit check is executed and passes, ensuring the bundle size remains below the specified threshold.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Set up Changesets for Automated Releases",
        "description": "Set up Changesets for automated semantic versioning and release management.",
        "details": "Install Changesets CLI. Run `changeset init` to set up the necessary files. Document the process for adding changesets for future contributions.",
        "testStrategy": "Follow the Changesets workflow to create a changeset, run `changeset version`, and verify that version bumps and changelog entries are generated correctly.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Build Live Demo Website (Vite)",
        "description": "Build the live demo website using Vite, consuming the UMD bundle.",
        "details": "Set up a new project directory for the demo site (e.g., `demo`). Use Vite to serve static HTML, CSS, and minimal vanilla JS. The JS should import and use the generated UMD bundle of `numis` to provide real-time parsing functionality.\n<info added on 2025-07-01T09:29:55.720Z>\nClarification: The Vite demo should be an entirely separate project located in the `demo/` directory, with its own `package.json`, dependencies, and `vite.config.js`. The demo’s build/dev scripts must not run as part of the library’s main `build` or `prepare` steps. The root package remains focused solely on building the NPM package.\n\nImplementation adjustments:\n• All Vite config and dependencies live inside `demo/`.\n• Root `package.json` scripts only expose optional `dev:demo` and `build:demo` that delegate into `demo/` (e.g., `npm --prefix demo run dev`).\n• The existing library build/prepare flow remains unchanged.\n\nSubtasks 32.1–32.6 remain valid but implicitly operate within the isolated `demo/` project structure.\n</info added on 2025-07-01T09:29:55.720Z>",
        "testStrategy": "Run the Vite development server for the demo site. Open the site in a browser and verify that the `numis` library is loaded and the real-time parsing feature works as expected.",
        "priority": "medium",
        "dependencies": [
          28
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite project in demo directory",
            "description": "Create a new Vite project inside the existing demo/ folder, configured for vanilla JS.",
            "details": "1. Run `npm create vite@latest demo -- --template vanilla` in project root.\n2. Adjust Vite config/output paths if needed so assets build into demo/dist.\n3. Add script entries `dev:demo` and `build:demo` to package.json.\n4. Verify `npm run dev:demo` serves the demo site on localhost.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 2,
            "title": "Integrate numis UMD bundle",
            "description": "Add the generated numis UMD script into the Vite demo project.",
            "details": "1. Ensure the build step for numis UMD (Task 28) outputs `dist/umd/numis.min.js`.\n2. Copy or link the UMD file into demo/public (or use Vite static asset import).\n3. Include `<script src=\"/numis.min.js\"></script>` in `index.html` and verify `window.monetJs` exists.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 3,
            "title": "Implement Testing Area UI",
            "description": "Add a textarea/input and results panel so users can paste text and view parsed monetary data.",
            "details": "1. In `index.html`, create a `<textarea id=\"input\">` and a `<pre id=\"output\"></pre>`.\n2. Add a \"Parse\" button or use `input` event listener for real-time parsing.\n3. Basic styling: responsive layout, monospaced output block.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 4,
            "title": "Wire numis parsing logic",
            "description": "Hook up the UI to call numis parse function and display structured results.",
            "details": "1. In `main.js`, add event listener on textarea or button.\n2. Call `window.monetJs.parseMoney(text)`.\n3. Format returned object as JSON using `JSON.stringify(result,null,2)` and inject into `output` pre.\n4. Handle errors gracefully.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 5,
            "title": "Add styling and user experience polish",
            "description": "Refine CSS and interactions for the demo site.",
            "details": "1. Add basic CSS for layout, fonts, colors.\n2. Highlight parsed output (e.g., syntax highlighting via Prism.js optional).\n3. Ensure mobile responsiveness.\n4. Add footer with project link and version.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 6,
            "title": "Document build and deployment",
            "description": "Write README/demo docs explaining how to build and run the demo site locally or deploy to GitHub Pages.",
            "details": "1. Add section in root README or demo/README with commands `npm run build:demo` and `npm run dev:demo`.\n2. Provide instructions for GitHub Pages deployment via `vite build --base /monet/`.\n3. Include screenshot/gif of testing area in action.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 7,
            "title": "Upgrade demo to full Vite app with enhanced UI",
            "description": "Convert static demo into a small Vite application with modular JS and polished UI.",
            "details": "1. Move inline CSS into dedicated `style.css`, link it via <link>.\n2. Improve layout with flexbox, responsive design, and better typography/colors.\n3. Update `main.js` to parse on textarea input (debounced) and show results in real time; add error handling.\n4. Separate logic from markup for cleaner structure.\n5. Ensure zero external dependencies beyond Vite.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          },
          {
            "id": 8,
            "title": "Convert demo to Vite React app",
            "description": "Rebuild demo using Vite + React for richer example.",
            "details": "1. Add React, ReactDOM, and @vitejs/plugin-react as dependencies in demo/package.json.\n2. Update vite.config.js to use react plugin.\n3. Move UI into React components (App.jsx) with textarea, result panel.\n4. Render via main.jsx.\n5. Keep numis UMD bundle in public and access via window.monetJs.\n6. Style using existing CSS.\n7. Update README instructions.\n<info added on 2025-07-01T12:38:16.956Z>\n8. Import RegexPipeline from numis and use `new RegexPipeline().run()` instead of `parseMoney` (as `parseMoney` is not yet exported).\n</info added on 2025-07-01T12:38:16.956Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 32
          }
        ]
      },
      {
        "id": 33,
        "title": "Configure GitHub Pages Deployment for Demo Site",
        "description": "Configure GitHub Pages deployment for the demo website via GitHub Actions.",
        "details": "Update the GitHub Actions workflow or create a new one to build the demo site (Task 32) and deploy the output to GitHub Pages on pushes to a specific branch (e.g., `main` or `gh-pages`).",
        "testStrategy": "Push changes to trigger the deployment workflow. Verify that the demo site is successfully deployed and accessible via the GitHub Pages URL.",
        "priority": "medium",
        "dependencies": [
          29,
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Add Build Step to CI Pipeline",
        "description": "Reintroduce the 'npm run build' step into the GitHub Actions workflow (ci.yml) to ensure build artifacts are generated during CI runs.",
        "details": "Modify the '.github/workflows/ci.yml' file. Add a step that runs 'npm run build' after the linting and testing steps have successfully completed. Ensure the build command is correct and the step is named appropriately, e.g., 'Build Library'. This step should execute the build configurations defined in tasks 27 and 28.",
        "testStrategy": "Trigger the CI workflow by pushing a change or opening a pull request. Verify that the 'Build Library' step is executed in the workflow run and completes successfully without errors. Check the workflow logs to confirm the 'npm run build' command was run and produced the expected output artifacts.",
        "status": "done",
        "dependencies": [
          29,
          27,
          28
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Build Production Demo Using Published NPM Package",
        "description": "Create a production-ready demo that installs and uses the published numis package from npm.",
        "details": "This task should be completed after all other features are implemented and the package is published to npm. The demo should install the numis package from npm rather than using local imports, ensuring proper dependency resolution and demonstrating real-world usage. This approach will solve the current ESM import issues and provide a genuine showcase of how users would integrate the library.\n\nSteps:\n1. Publish the numis package to npm (either public or as a scoped package)\n2. Update the demo project to install the package from npm\n3. Modify imports in the demo to use the npm package rather than local paths\n4. Update the vite.config.js to remove the local path aliases\n5. Test the demo to ensure it works correctly with the published package\n6. Document the process in the README",
        "testStrategy": "Verify that the demo runs correctly with the published npm package. Ensure all features work as expected and that there are no dependency resolution issues.",
        "status": "done",
        "dependencies": [
          32
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Optimize numis for Demo and Bundle Size",
        "description": "Optimize numis for demo-ready one-call parsing with minimal bundle size. This includes lazy initialization, tree-shaking improvements, and updating demo usage to showcase the optimized library.",
        "details": "1.  **Lazy Initialization:** Implement lazy initialization for non-core components and parsers. This will reduce the initial bundle size by deferring the loading of less frequently used features until they are actually needed.\n2.  **Tree-Shaking Analysis:** Analyze the current bundle using a tree-shaking analyzer (e.g., webpack-bundle-analyzer) to identify opportunities for further size reduction.  Focus on removing dead code and ensuring that only necessary modules are included in the final bundle.\n3.  **Code Splitting:** Explore code splitting strategies to further reduce the initial load time.  Consider splitting the bundle into smaller chunks based on functionality or usage patterns.\n4.  **Dependency Optimization:** Review and update dependencies to ensure they are the latest versions and that they are not contributing unnecessarily to the bundle size.  Consider replacing larger dependencies with smaller, more focused alternatives where appropriate.\n5.  **Demo Update:** Update the demo to showcase the optimized library and its one-call parsing capabilities.  Ensure the demo is easy to use and provides clear examples of how to use the library effectively.\n6.  **Documentation:** Update documentation to reflect the changes made during optimization, including any new APIs or usage patterns.",
        "testStrategy": "1.  **Bundle Size Verification:** Measure the bundle size before and after optimization to ensure that the changes have resulted in a significant reduction in size.  Use tools like webpack-bundle-analyzer to compare the bundle contents.\n2.  **Performance Testing:** Conduct performance testing to ensure that the optimizations have not negatively impacted the parsing speed or overall performance of the library.  Focus on testing the one-call parsing functionality with a variety of inputs.\n3.  **Functional Testing:** Run existing unit tests to ensure that all existing functionality continues to work as expected after the optimizations.\n4.  **Demo Testing:** Thoroughly test the updated demo to ensure that it is easy to use, provides clear examples, and accurately showcases the optimized library.\n5.  **Tree-Shaking Verification:** Verify that tree-shaking is working correctly by inspecting the generated bundle and ensuring that unused code has been removed.",
        "status": "done",
        "dependencies": [
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add one-call parseMoney API",
            "description": "Expose a top-level parseMoney(text) that wraps RegexPipeline.default().run and returns structured output.",
            "details": "Maintain default all-pattern coverage; keep RegexPipeline export for advanced use.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 2,
            "title": "Make heavy initializations lazy/memoized",
            "description": "Defer currency name/code map construction and other heavy lookups until first call to reduce bundle impact.",
            "details": "Ensure contextual phrases and regex pipeline build maps on demand; keep behavior identical.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 3,
            "title": "Centralize currency map building",
            "description": "Build currency name/code maps once in a shared helper to avoid duplicate currency-codes pulls across modules.",
            "details": "Ensure both regex pipeline and contextual phrases reuse the same lazy map builder to minimize bundle size.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 4,
            "title": "Add browser-friendly entry + demo import",
            "description": "Expose a clear ESM entry (e.g., parseMoney) for Vite/React demo and update demo to consume it.",
            "details": "Keep all patterns active by default; ensure demo import path uses published package entry and benefits from tree-shaking.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "Implement Example Prompts UI Component",
        "description": "Create a UI component for the demo website that displays random example monetary expressions, allowing users to populate the input field with a click.",
        "details": "1.  Create a new UI component (e.g., `ExamplePrompts.vue` or `example-prompts.js`) within the Vite demo project.\n2.  Define an array of diverse example monetary expressions (strings) covering various patterns (symbols, abbreviations, worded numbers, regional formats, etc.). Aim for at least 10-15 examples.\n3.  Implement logic to randomly select 3 examples from the array when the component is mounted or refreshed.\n4.  Display the selected examples as clickable elements (e.g., buttons or styled divs).\n5.  Attach a click event listener to each example element. When clicked, the selected example should populate the main input field of the demo website.\n6.  Style the component to visually integrate with the existing demo website design.\n7.  Ensure the component is responsive and works well on different screen sizes.\n8.  Consider adding a \"Refresh Examples\" button to allow users to generate a new set of random examples.\n9.  The example prompts should cover a range of currency formats and amounts to showcase the parser's capabilities. Examples: [\"$100\", \"EUR 50\", \"GBP 20.50\", \"100 CAD\", \"one hundred dollars\", \"half a dollar\", \"10k\", \"1.234,56 €\", \"buck\", \"1,000,000\", \"USD 12.50\", \"£1000\", \"5m\", \"quarter pound\"]",
        "testStrategy": "1.  Verify that the Example Prompts component is displayed correctly on the demo website.\n2.  Confirm that 3 random examples are displayed each time the component is loaded or refreshed (if a refresh button is implemented).\n3.  Click each example prompt and verify that the corresponding text is correctly populated into the main input field of the demo website.\n4.  Test with different screen sizes to ensure the component is responsive and the examples are displayed correctly.\n5.  Check that the example prompts cover a variety of currency formats and amounts.\n6.  Manually test a large number of example selections to ensure randomness and that no errors occur.",
        "status": "done",
        "dependencies": [
          10,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20,
          32
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Example Monetary Expressions",
            "description": "Create an array of diverse example monetary expressions (strings) covering various patterns (symbols, abbreviations, worded numbers, regional formats, etc.). Aim for at least 15 examples.",
            "dependencies": [],
            "details": "Create a `const` array named `examplePrompts` in a new file (e.g., `src/components/examplePromptsData.js`). This array should contain strings representing monetary amounts in various formats. Include examples like: ['$100', 'EUR 50', 'GBP 20.50', '100 CAD', 'one hundred dollars', 'half a dollar', '10k', '1.234,56 €', 'buck', '1,000,000', 'USD 12.50', '£1000', '5m', 'quarter pound', '20 quid']. Export the array.",
            "status": "done",
            "testStrategy": "Manually inspect the `examplePromptsData.js` file to ensure the array contains a diverse set of monetary expressions."
          },
          {
            "id": 2,
            "title": "Build Example Prompts Component",
            "description": "Create a new UI component (e.g., `ExamplePrompts.vue` or `example-prompts.js`) within the Vite demo project. This component will display the example prompts.",
            "dependencies": [],
            "details": "Create a new Vue component file (e.g., `src/components/ExamplePrompts.vue`). Import the `examplePrompts` array from `src/components/examplePromptsData.js`. In the component's `data` or `reactive` section, create a variable to hold the randomly selected prompts. Implement a method to randomly select 3 examples from the `examplePrompts` array when the component is mounted or when a 'Refresh Examples' button is clicked. Display the selected examples as clickable elements (e.g., buttons or styled divs).",
            "status": "done",
            "testStrategy": "Verify that the component renders without errors and displays 3 example prompts from the array. Check that the prompts are different each time the component is mounted or refreshed."
          },
          {
            "id": 3,
            "title": "Implement Click Handler",
            "description": "Attach a click event listener to each example element. When clicked, the selected example should populate the main input field of the demo website.",
            "dependencies": [],
            "details": "In the `ExamplePrompts.vue` component, add a click event listener to each clickable example element. The click handler should retrieve the text content of the clicked element and use it to update the value of the main input field in the parent component. Use Vue's event emission (`$emit`) to communicate the selected example to the parent component. The parent component should then update the input field.",
            "status": "done",
            "testStrategy": "Click each example prompt and verify that the main input field is populated with the corresponding text. Ensure that the input field is updated correctly for all example prompts."
          },
          {
            "id": 4,
            "title": "Style the Example Prompts Component",
            "description": "Style the component to visually integrate with the existing demo website design. Ensure the component is responsive and works well on different screen sizes.",
            "dependencies": [],
            "details": "Apply CSS styles to the `ExamplePrompts.vue` component to match the overall design of the demo website. Use CSS classes or inline styles to format the example prompts, the 'Refresh Examples' button (if implemented), and the container element. Ensure the component is responsive by using media queries or a responsive CSS framework (e.g., Bootstrap, Tailwind CSS).",
            "status": "done",
            "testStrategy": "Inspect the component in different browsers and screen sizes to ensure it is visually appealing and responsive. Verify that the styles are consistent with the rest of the demo website."
          },
          {
            "id": 5,
            "title": "Integrate and Test the Feature",
            "description": "Integrate the Example Prompts component into the main demo website and test the complete feature.",
            "dependencies": [],
            "details": "Import the `ExamplePrompts.vue` component into the main demo website component. Place the component in a suitable location on the page. Implement the logic in the parent component to receive the selected example from the `ExamplePrompts` component and update the input field accordingly. Test the entire feature by clicking on the example prompts and verifying that the input field is updated correctly. Test the 'Refresh Examples' button (if implemented) to ensure it generates new random examples.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing of the feature by interacting with the Example Prompts component and verifying that the input field is updated correctly. Test the feature on different browsers and screen sizes. Verify that the 'Refresh Examples' button (if implemented) works as expected."
          }
        ]
      },
      {
        "id": 38,
        "title": "Implement Custom Default Currency for parseMoney()",
        "description": "Add a custom default currency option to the numis SDK's parseMoney() function, allowing users to specify a fallback currency when none is detected in the input text.",
        "details": "1.  **Create ParseOptions Interface:** Define a `ParseOptions` interface with an optional `defaultCurrency` field (string, ISO-4217 code). The default value should be 'USD' for backwards compatibility.\n2.  **Update parseMoney() Signature:** Modify the `parseMoney()` function signature to accept an optional `options` parameter of type `ParseOptions`.\n3.  **Modify RegexPipeline:** Update the RegexPipeline to propagate the `defaultCurrency` option. If no currency is detected by the regex, apply the `defaultCurrency` from the options.\n4.  **Currency Code Validation:** Validate the `defaultCurrency` code against the `currency-codes` package to ensure it's a valid ISO-4217 currency code. Throw a `MoneyParseError` if the code is invalid.\n5.  **Update README Documentation:** Add examples to the README demonstrating how to use the `defaultCurrency` option.\n6.  **Demo Website Integration:** Add a currency dropdown selector to the demo website (`demo/src/App.jsx`) allowing users to select a default currency and see its effect on parsing. The dropdown should be populated with common currencies (USD, EUR, GBP, etc.).\n\nExample Code:\n\n```typescript\ninterface ParseOptions {\n  defaultCurrency?: string;\n}\n\nfunction parseMoney(text: string, options?: ParseOptions): Money | undefined {\n  const defaultCurrency = options?.defaultCurrency ?? 'USD';\n  // ... rest of the parsing logic\n}\n```",
        "testStrategy": "1.  **Unit Tests:**\n    *   Write unit tests for `parseMoney()` with different `defaultCurrency` options (e.g., 'EUR', 'GBP', 'JPY').\n    *   Verify that the correct currency is returned when no currency is detected in the input text and a `defaultCurrency` is provided.\n    *   Verify that the default currency is 'USD' when no options are provided.\n    *   Write a unit test to ensure that an invalid currency code passed as `defaultCurrency` throws a `MoneyParseError`.\n2.  **Demo Website Testing:**\n    *   Verify that the currency dropdown selector is displayed correctly on the demo website.\n    *   Verify that selecting a currency from the dropdown updates the `defaultCurrency` used by `parseMoney()`.\n    *   Verify that the parsing results on the demo website reflect the selected `defaultCurrency` when no currency is detected in the input text.\n    *   Test with various input strings and different default currencies to ensure the functionality works as expected.\n3.  **End-to-End Tests:**\n    *   Create end-to-end tests that simulate user interactions on the demo website, including selecting a default currency and entering monetary expressions. Verify that the parsing results are correct.",
        "status": "done",
        "dependencies": [
          5,
          6,
          20,
          32,
          37
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ParseOptions Interface",
            "description": "Define the `ParseOptions` interface with an optional `defaultCurrency` field (string, ISO-4217 code).",
            "dependencies": [],
            "details": "Create a new file `src/types/ParseOptions.ts` (or add to an existing types file) and define the `ParseOptions` interface. The `defaultCurrency` field should be optional and of type string. Set the default value to 'USD' in the `parseMoney` function if the option is not provided.",
            "status": "done",
            "testStrategy": "N/A - Type definition only."
          },
          {
            "id": 2,
            "title": "Update parseMoney() Function Signature",
            "description": "Modify the `parseMoney()` function signature to accept an optional `options` parameter of type `ParseOptions`.",
            "dependencies": [],
            "details": "Update the `parseMoney()` function signature in `src/parseMoney.ts` to accept an optional `options` parameter of type `ParseOptions`. Ensure backwards compatibility by providing a default value for the options parameter if it's not provided.",
            "status": "done",
            "testStrategy": "Create a unit test to ensure that `parseMoney` still works correctly when no options are passed."
          },
          {
            "id": 3,
            "title": "Update RegexPipeline to Propagate defaultCurrency",
            "description": "Update the RegexPipeline to accept and propagate the `defaultCurrency` option through the PipelineContext.",
            "dependencies": [],
            "details": "Modify the `RegexPipeline.run()` method to accept the `defaultCurrency` from the `ParseOptions` and pass it down to the `PipelineContext`. This will make the `defaultCurrency` available to the currency detection step.",
            "status": "done",
            "testStrategy": "Add a unit test to verify that the `defaultCurrency` is correctly passed to the `PipelineContext`."
          },
          {
            "id": 4,
            "title": "Modify Currency Detection to Apply Default Currency",
            "description": "Modify the currency detection step in the RegexPipeline to apply the `defaultCurrency` as a fallback when no currency is detected in the input text.",
            "dependencies": [],
            "details": "Within the currency detection logic in the RegexPipeline, check if a currency has been detected. If not, use the `defaultCurrency` from the `PipelineContext` to create a `Currency` object. Ensure that the original detected value is null if the default currency is applied.",
            "status": "done",
            "testStrategy": "Create unit tests to verify that the `defaultCurrency` is correctly applied when no currency is detected in the input text. Also, test cases where a currency is detected, ensuring the detected currency takes precedence."
          },
          {
            "id": 5,
            "title": "Add Validation for defaultCurrency",
            "description": "Validate the `defaultCurrency` code against the `currency-codes` package to ensure it's a valid ISO-4217 currency code. Throw a `MoneyParseError` if the code is invalid.",
            "dependencies": [],
            "details": "Use the `currency-codes` package to validate the `defaultCurrency` code within the `parseMoney()` function. If the code is invalid, throw a `MoneyParseError` with a descriptive message. Ensure the validation happens before the RegexPipeline is executed.",
            "status": "done",
            "testStrategy": "Create unit tests to verify that a `MoneyParseError` is thrown when an invalid currency code is provided as the `defaultCurrency`. Also, test with valid currency codes to ensure no error is thrown."
          },
          {
            "id": 6,
            "title": "Update README Documentation",
            "description": "Add examples to the README demonstrating how to use the `defaultCurrency` option.",
            "dependencies": [],
            "details": "Update the `README.md` file with clear examples of how to use the `defaultCurrency` option in the `parseMoney()` function. Include examples with valid and invalid currency codes. Also, add JSDoc comments to new interfaces and updated functions.",
            "status": "done",
            "testStrategy": "Manually review the README to ensure the examples are clear and accurate."
          },
          {
            "id": 7,
            "title": "Add Currency Dropdown to Demo Website",
            "description": "Add a currency dropdown selector to the demo website (`demo/src/App.jsx`) allowing users to select a default currency.",
            "dependencies": [],
            "details": "Modify the `demo/src/App.jsx` file to include a currency dropdown selector. Populate the dropdown with common currencies (USD, EUR, GBP, JPY, etc.). Store the selected currency in the component's state.",
            "status": "done",
            "testStrategy": "Manually test the demo website to ensure the dropdown is displayed correctly and populated with the correct currencies."
          },
          {
            "id": 8,
            "title": "Wire Up Dropdown to Pass defaultCurrency to parseMoney and Show Visual Indication",
            "description": "Wire up the currency dropdown to pass the selected `defaultCurrency` option to the `parseMoney()` function and show a visual indication when the default currency is being applied vs detected currency.",
            "dependencies": [],
            "details": "Update the `demo/src/App.jsx` file to pass the selected currency from the dropdown to the `parseMoney()` function as the `defaultCurrency` option. Add logic to display a visual indication (e.g., a message or different styling) when the `defaultCurrency` is being applied instead of a detected currency. The visual indication should clearly communicate whether the parsed currency was detected or defaulted.",
            "status": "done",
            "testStrategy": "Manually test the demo website to ensure the selected currency is correctly passed to `parseMoney()` and that the visual indication is displayed correctly when the `defaultCurrency` is being applied."
          }
        ]
      },
      {
        "id": 39,
        "title": "Fix Decimal Numbers Before Magnitude Words",
        "description": "Fix the issue where decimal numbers followed by magnitude words (e.g., '2.25 thousand') are not correctly parsed, resulting in incorrect numeric values. This task involves modifying the `parseAmountTokens` function in `contextualPhrases.ts` to properly handle this scenario.",
        "details": "Modify the regex check within the `parseAmountTokens` function in `contextualPhrases.ts` to correctly identify and process decimal numbers followed by magnitude words. The current regex prematurely matches the full string, causing an early return with an incorrect value. The updated regex should specifically target the numeric part and the magnitude word, allowing for accurate calculation. Ensure that the fix handles various magnitude words (thousand, million, billion, etc.) and different decimal formats. Consider adding a new unit test file to isolate these tests from the other unit tests.",
        "testStrategy": "Create new unit tests specifically for decimal numbers followed by magnitude words. These tests should cover a range of values and magnitude words, including '2.25 thousand', '1.5 million', '0.75 billion', etc. Verify that the parsed values are accurate (e.g., '2.25 thousand' should return 2250). Also, test edge cases such as very small decimal numbers (e.g., '0.001 million') and very large numbers (e.g., '999.999 million'). Ensure that the existing unit tests are not negatively impacted by this change. Run all unit tests to confirm the fix does not introduce regressions.",
        "status": "done",
        "dependencies": [
          7,
          9,
          10,
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Integrate Regional Format Parser into Main Pipeline",
        "description": "Integrate the existing regional format parser into the main regex pipeline to correctly handle European decimal separators and other regional number formats. This includes adding the parser to the pipeline, handling ambiguity, and adding comprehensive tests.",
        "details": "1.  **Add regionalFormatDetectionStep to pipeline:** Modify the `regexPipeline` to include the `regionalFormatDetectionStep` before the `plainNumericDetection` step. This ensures that regional formats are parsed before attempting to parse numbers with US-style formatting.\n2.  **Handle ambiguity detection for \"1.000\":** Implement logic to differentiate between European \"1.000\" (one thousand) and US \"1.0\" (one point zero). This may involve checking for surrounding currency symbols or other contextual clues. Consider adding a configuration option to specify the default locale if ambiguity cannot be resolved.\n3.  **Update regexPipeline:** Ensure the regional format parser is correctly instantiated and configured within the `regexPipeline`.\n4.  **Error Handling:** Implement robust error handling to gracefully manage cases where regional format parsing fails or produces unexpected results. Log errors appropriately for debugging purposes.\n5.  **Performance Considerations:** Evaluate the performance impact of adding the regional format parser to the pipeline. Optimize the parser's implementation to minimize any performance overhead.",
        "testStrategy": "1.  **Comprehensive tests for European format:** Create a suite of unit tests specifically designed to test the regional format parser with European number formats. These tests should include:\n    *   Numbers with period as thousands separator: \"1.000.000\", \"10.000\"\n    *   Numbers with comma as decimal separator: \"1,234\", \"123,45\"\n    *   Numbers with currency symbols: \"1.234,56 EUR\", \"1.000.000,00 $\"\n    *   Numbers with mixed formats (if applicable).\n2.  **Ambiguity tests:** Create tests to specifically address the ambiguity of numbers like \"1.000\". These tests should include cases where the context suggests a European format and cases where it suggests a US format.\n3.  **Regression tests:** Run existing tests to ensure that the integration of the regional format parser does not negatively impact the parsing of other number formats.\n4.  **Edge case tests:** Include tests for edge cases such as invalid or malformed input strings.\n5.  **Performance tests:** Measure the execution time of the pipeline with and without the regional format parser to identify any performance regressions.",
        "status": "done",
        "dependencies": [
          19,
          10,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Negative Number Support",
        "description": "Add functionality to correctly identify and handle negative numbers in currency strings, including negative prefixes, parentheses notation, and updating the pipeline context.",
        "details": "1. **Create negative detection utilities:** Implement functions to detect negative prefixes such as \"-\", \"minus\", and \"negative\" before the currency amount. Also, implement logic to detect parentheses notation, where (100) implies -100.\n2. **Add negativeDetectionStep to pipeline:** Integrate a new step early in the parsing pipeline to utilize the negative detection utilities. This step should identify and flag negative amounts before other parsers are applied.\n3. **Store negative flag in PipelineContext:** Modify the PipelineContext to include an `isNegative` boolean flag. The `negativeDetectionStep` should set this flag accordingly.\n4. **Apply negative flag to final amount:** At the end of the pipeline, apply the `isNegative` flag to the final extracted amount. If the flag is true, multiply the amount by -1.\n5. **Handle parentheses notation:** Implement logic to detect and handle parentheses notation, where (100) implies -100. This should be integrated into the negative detection utilities.\n6. **Update type definitions:** Update relevant type definitions (e.g., interfaces for PipelineContext, parser outputs) to include the `isNegative` flag.\n7. **Consider interactions with existing parsers:** Ensure the negative number handling logic interacts correctly with all existing parsers (e.g., Symbols, Abbreviations, Regional Formats). Pay special attention to the order of operations to avoid conflicts.\n8. **Group Assignment:** This task belongs to Group C.",
        "testStrategy": "1. **Unit tests for negative detection utilities:** Create unit tests to verify the correct detection of negative prefixes (\"-\", \"minus\", \"negative\") and parentheses notation.\n2. **Integration tests for the pipeline:** Write integration tests to verify the entire pipeline correctly handles negative numbers in various formats, including:\n    *   Negative prefixes: \"-100 EUR\", \"minus 50 USD\", \"negative 25 GBP\"\n    *   Parentheses notation: \"(100) USD\", \"(50.50) EUR\"\n    *   Combinations with existing patterns: \"-$100\", \"(EUR 50)\", \"-1,234.56 USD\"\n3. **Comprehensive testing with all existing patterns:** Combine negative number patterns with all existing patterns (Symbols, Abbreviations, Regional Formats, Worded Numbers, etc.) to ensure no regressions are introduced. This includes positive and negative cases.\n4. **Edge cases:** Test edge cases such as multiple negative prefixes (e.g., \"--100 EUR\") and invalid parentheses (e.g., \"(100 EUR\").\n5. **Test the isNegative flag:** Verify that the `isNegative` flag in the PipelineContext is correctly set and applied to the final amount.",
        "status": "done",
        "dependencies": [
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          19,
          20
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Extend Fractional Parser to Support Magnitude Words",
        "description": "Extend the fractional parser to correctly handle magnitude words (e.g., 'million', 'billion') following fractions, addressing the issue where 'a quarter million' currently returns 0.25 instead of 250000. This task involves modifying the parser and adding comprehensive tests.",
        "details": "1) Extend `parseFractionalWordedNumber` to handle optional magnitude words after fractions. This will likely involve adding a new regular expression or conditional logic to detect and parse magnitude words.\n2) Implement parsing logic for the pattern: fraction + magnitude (e.g., 'quarter million', 'half billion'). Ensure correct multiplication of the fractional value with the magnitude value.\n3) Implement parsing logic for the pattern: fraction + 'of a' + magnitude (e.g., 'quarter of a million'). Handle the 'of a' phrase correctly to extract the magnitude.\n4) Integrate the updated parser into `contextualPhrases` to support this pattern in contextual parsing scenarios. This may require modifications to the contextual parsing logic to recognize and utilize the new fractional magnitude pattern.\n5) Update documentation to reflect the changes made to the fractional parser and the new supported patterns.",
        "testStrategy": "1) Create unit tests for all fractional magnitude combinations, including 'quarter million', 'half billion', 'third trillion', etc. Verify that the parser returns the correct numeric value for each combination.\n2) Create unit tests for the 'fraction + of a + magnitude' pattern, such as 'quarter of a million', 'half of a billion', etc. Verify correct parsing and numeric conversion.\n3) Add tests to `contextualPhrases` to ensure the new pattern is correctly parsed in contextual scenarios. Test with various surrounding words and phrases to ensure accurate results.\n4) Test with different fractional values (e.g., 'one fifth', 'three quarters') combined with different magnitudes (e.g., 'thousand', 'million', 'billion').\n5) Include edge cases and boundary conditions in the tests, such as very large magnitudes or unusual fractional values.",
        "status": "done",
        "dependencies": [
          7,
          9,
          15,
          16
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Enhance Minor Unit Handling in Contextual Phrases",
        "description": "Update the contextualPhrases regex to optionally include 'and' between major and minor currency units, and add validation to ensure correct minor unit parsing.",
        "details": "1. Modify the contextualPhrases regular expression to make the 'and' connector optional between major and minor currency units (e.g., allow both '5 pounds and 20 pence' and '5 pounds 20 pence').\n2. Implement validation to confirm that the trailing number after the major unit is a valid minor unit (e.g., less than 100 for cents, pence, etc.).\n3. Ensure compatibility with colloquial patterns like 'a dollar fifty' and extend support to patterns like '5 pounds 20'.\n4. Add comprehensive unit tests covering all major+minor currency combinations, both with and without the 'and' connector (e.g., '5 pounds 20 pence', '2 euros 50', 'ten dollars 25', '5 pounds and 20 pence').\n5. Implement validation to ensure the minor amount is valid (e.g., less than 100 for cents/pence).\n6. Update relevant documentation to reflect the support for both formats (with and without 'and').",
        "testStrategy": "1. Create unit tests for various currency combinations with and without the 'and' connector (e.g., '5 pounds 20 pence', '2 euros 50', 'ten dollars 25', '5 pounds and 20 pence', '10 dollars and 99 cents').\n2. Verify that the parser correctly extracts the major and minor units in all test cases.\n3. Implement negative test cases with invalid minor unit amounts (e.g., '5 pounds 150 pence') and ensure they are correctly rejected.\n4. Test with different currencies to ensure the validation logic is currency-specific (e.g., validate against 100 for cents/pence, but adjust for other currencies with different minor unit ranges if applicable).\n5. Verify that the updated documentation accurately reflects the supported formats.",
        "status": "done",
        "dependencies": [
          12,
          13,
          19,
          20
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-22T05:27:52.739Z",
      "updated": "2026-01-10T13:11:10.035Z",
      "description": "Tasks for master context"
    }
  }
}